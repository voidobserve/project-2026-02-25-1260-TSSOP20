C51 COMPILER V9.60.7.0   ENGINE                                                            01/26/2026 10:01:40 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ENGINE
OBJECT MODULE PLACED IN .\Release\Objects\engine.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\engine.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCD
                    -IR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\engine.lst) OBJECT(.\Rele
                    -ase\Objects\engine.obj)

line level    source

   1          #include "my_config.h"
   2          #include "engine.h"
   3          
   4          /*
   5              æ»¤æ³¢ã€åˆ¤æ–­ç”µå‹æ˜¯å¦æœ‰è·³åŠ¨ï¼Œä¸€æ®µæ—¶é—´å†…ç”µå‹æµ®åŠ¨è¿‡å¤§ï¼Œ
   6              æ‰€ä½¿ç”¨åˆ°çš„è¿™äº›å˜é‡
   7          */
   8          #define FILTER_BUFF_SIZE 32
   9          #define FILTER_BUFF_2_SIZE 270 // 270 -- å¯¹åº” 5.83ms æ‰§è¡Œä¸€æ¬¡çš„å‡½æ•° according_pin9_to_adjust_pwmï
             -¼Œæ—¶é—´è¶ŠçŸ­ï¼Œæ•°ç»„éœ€è¦åŠ å¤§
  10          // #define FILTER_BUFF_2_SIZE 540 // 540 -- å¯¹åº” 2.93ms æ‰§è¡Œä¸€æ¬¡çš„å‡½æ•° according_pin9_to_adjust_p
             -wmï¼Œæ—¶é—´è¶ŠçŸ­ï¼Œæ•°ç»„éœ€è¦åŠ å¤§
  11          static volatile u16 t_count = 0;
  12          static volatile u16 t_adc_max = 0;    // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å¤§adå€¼
  13          static volatile u16 t_adc_min = 4096; // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å°adå€¼
  14          static volatile u8 over_drive_status = 0;
  15          #define OVER_DRIVE_RESTART_TIME (30)
  16          
  17          static volatile u16 filter_buff[FILTER_BUFF_SIZE] = {
  18              0xFFFF,
  19          };
  20          
  21          // static volatile u16 filter_buff_2[270] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„ (å¯¹åº” 5.83ms æ‰§è¡Œä¸€æ¬¡çš„å‡
             -½æ•° according_pin9_to_adjust_pwm )
  22          // static volatile u16 filter_buff_2[25] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„
  23          static volatile u16 filter_buff_2[FILTER_BUFF_2_SIZE]; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„
  24          static volatile u16 filter_buff_2_index;               // ç”¨äºè®°å½•æ»¤æ³¢çš„æ•°ç»„ä¸‹æ ‡
  25          
  26          volatile bit flag_is_time_to_check_engine; // æ ‡å¿—ä½ï¼Œæ˜¯å¦åˆ°æ—¶é—´å»è°ƒç”¨æ£€æµ‹å‘åŠ¨æœºåŠŸç‡çš„
             -å‡½æ•°
  27          
  28          /*
  29              ç”µæºç”µå‹ä½äº170V-AC,å¯åŠ¨ä½å‹ä¿æŠ¤ï¼Œç”µæºç”µå‹é«˜äº170V-ACï¼Œå…³é—­ä½å‹ä¿æŠ¤
  30              æ¸©åº¦æ­£å¸¸ï¼Œæ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ
  31              æ³¨æ„ï¼Œæ¯æ¬¡è°ƒç”¨åˆ°è¯¥å‡½æ•°ï¼Œåº”è¯¥åœ¨5.75mså·¦å³ï¼Œæ£€æµ‹å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®šçš„åŸç†æ˜¯
             -æ£€æµ‹é¢‘ç‡ï¼Œ
  32              å¦‚æœä¸åœ¨5.75msé™„è¿‘ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ£€æµ‹ä¸å‡†ç¡®ï¼Œæ£€æµ‹ä¸åˆ°å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®š
  33          */
  34          void according_pin9_to_adjust_pwm(void)
  35          {
  36   1          static volatile u8 filter_buff_index = 0;
  37   1          static volatile u8 flag_is_sub_power = 0;  // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡ï¼ˆçŠ¶æ€æœºï¼‰
  38   1          static volatile u8 flag_is_sub_power2 = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡
  39   1          static volatile bit flag_is_add_power = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å¢åŠŸç‡
  40   1      
  41   1          // volatile bit flag_is_engine_unstable = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦æ£€æµ‹åˆ°äº†å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®š
             -ï¼Œåªåœ¨è¯¥å‡½æ•°å†…ä½¿ç”¨
  42   1      
  43   1          volatile u32 adc_pin_9_avg = 0;             // å­˜æ”¾å¹³å‡å€¼
  44   1          volatile u16 adc_val = adc_val_from_engine; // adc_val_from_engine ç”±adcä¸­æ–­æ›´æ–°
  45   1      
  46   1          if (filter_buff[0] == 0xFFFF) // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ£€æµ‹ï¼Œè®©æ•°ç»„å†…æ‰€æœ‰å…ƒç´ éƒ½å˜ä¸ºç¬¬ä¸€æ¬¡
             -é‡‡é›†çš„æ•°æ®ï¼Œæ–¹ä¾¿å¿«é€Ÿä½œå‡ºå˜åŒ–
C51 COMPILER V9.60.7.0   ENGINE                                                            01/26/2026 10:01:40 PAGE 2   

  47   1          {
  48   2              u16 i = 0;
  49   2              for (; i < ARRAY_SIZE(filter_buff); i++)
  50   2              {
  51   3                  filter_buff[i] = adc_val;
  52   3              }
  53   2      
  54   2              for (i = 0; i < ARRAY_SIZE(filter_buff_2); i++)
  55   2              {
  56   3                  filter_buff_2[i] = adc_val;
  57   3              }
  58   2          }
  59   1          else
  60   1          {
  61   2              u16 temp = filter_buff[filter_buff_index];
  62   2              temp += adc_val;
  63   2              temp >>= 1;
  64   2              filter_buff[filter_buff_index] = temp;
  65   2              filter_buff_index++;
  66   2              if (filter_buff_index >= ARRAY_SIZE(filter_buff))
  67   2              {
  68   3                  filter_buff_index = 0;
  69   3              }
  70   2          }
  71   1      
  72   1          { // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
  73   2              u16 i = 0;
  74   2              for (; i < ARRAY_SIZE(filter_buff); i++)
  75   2              {
  76   3                  adc_pin_9_avg += filter_buff[i];
  77   3              }
  78   2      
  79   2              // adc_pin_9_avg /= ARRAY_SIZE(filter_buff);
  80   2              adc_pin_9_avg >>= 5; // ç›¸å½“äº /= 32
  81   2          } // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
  82   1      
  83   1          // åœ¨å‰é¢æ»¤æ³¢çš„åŸºç¡€ä¸Šå†è¿›è¡Œä¸€æ¬¡æ»¤æ³¢
  84   1          filter_buff_2[filter_buff_2_index] = adc_pin_9_avg;
  85   1          filter_buff_2_index++;
  86   1          if (filter_buff_2_index >= ARRAY_SIZE(filter_buff_2))
  87   1          {
  88   2              filter_buff_2_index = 0;
  89   2          }
  90   1      
  91   1          {
  92   2              u16 i = 0;
  93   2              t_adc_max = 0;
  94   2              t_adc_min = 4096;
  95   2              for (; i < ARRAY_SIZE(filter_buff_2); i++)
  96   2              {
  97   3                  if (filter_buff_2[i] > t_adc_max)
  98   3                  {
  99   4                      t_adc_max = filter_buff_2[i];
 100   4                  }
 101   3                  if (filter_buff_2[i] < t_adc_min)
 102   3                  {
 103   4                      t_adc_min = filter_buff_2[i];
 104   4                  }
 105   3                  if ((t_adc_max - t_adc_min) > ADC_OVER_DRIVE_VAL)
 106   3                  { // ç”µå‹æ³¢åŠ¨
 107   4                      over_drive_status = OVER_DRIVE_RESTART_TIME;
 108   4                  }
C51 COMPILER V9.60.7.0   ENGINE                                                            01/26/2026 10:01:40 PAGE 3   

 109   3                  else
 110   3                  {
 111   4                      if (over_drive_status)
 112   4                          over_drive_status--;
 113   4                  }
 114   3              }
 115   2      
 116   2              // MY_DEBUG:
 117   2              // {
 118   2              //     // æ ¹æ®å‘åŠ¨æœºä¸ç¨³å®šé™åŠŸç‡çš„åŠŸèƒ½æ­£å¸¸æ—¶ï¼Œæµ‹å¾—æ˜¯5.83msæ‰§è¡Œä¸€æ¬¡ï¼Œæ¯1
             -00æ¬¡æ‰“å°ä¸€æ¬¡ï¼Œå¹³å‡è€—æ—¶æ˜¯583ms
 119   2              //     // å¦‚æœå¾ªç¯å¤§äº5.83msï¼Œåœ¨å®¢æˆ·é‚£é‡Œæµ‹è¯•å¥½åƒåŠŸèƒ½ä¹Ÿæ­£å¸¸ï¼Œå®¢æˆ·æ²¡æœ‰è¿›ä
             -¸€æ­¥åé¦ˆ
 120   2              //     static u8 cnt = 0;
 121   2              //     cnt++;
 122   2              //     if (cnt >= 100)
 123   2              //     {
 124   2              //         cnt = 0;
 125   2              //         printf("__LINE__ %u\n", __LINE__);
 126   2              //     }
 127   2              // }
 128   2          }
 129   1      
 130   1          if (adc_pin_9_avg >= (ADC_VAL_170VAC + ADC_DEAD_ZONE_NEAR_170VAC) ||
 131   1              (flag_is_add_power && adc_pin_9_avg > (ADC_VAL_170VAC + ADC_DEAD_ZONE_NEAR_170VAC))) // å¤§äº 170
             -VAC
 132   1          {
 133   2              // å¤§äº170VACï¼Œæ¢å¤100%å ç©ºæ¯”ï¼Œä½†æ˜¯ä¼˜å…ˆçº§æ¯” "9è„šç”µå‹æ£€æµ‹åˆ°å‘é€æœºåŠŸç‡ä¸ç
             -¨³å®šï¼Œè¿›è€Œé™åŠŸç‡" ä½
 134   2              flag_is_sub_power = 0;
 135   2              flag_is_sub_power2 = 0;
 136   2              flag_is_add_power = 1;
 137   2      
 138   2              if (over_drive_status == OVER_DRIVE_RESTART_TIME) // 9è„šç”µå‹è¶…è¿‡ä¸ç¨³å®šé˜ˆå€¼å¯¹åº”çš„ç”µå
             -‹
 139   2              {
 140   3                  over_drive_status -= 1;
 141   3                  if (limited_pwm_duty_due_to_unstable_engine > PWM_DUTY_50_PERCENT)
 142   3                  {
 143   4                      limited_pwm_duty_due_to_unstable_engine -= 1;
 144   4                  }
 145   3      
 146   3                  if (limited_pwm_duty_due_to_unstable_engine < PWM_DUTY_50_PERCENT)
 147   3                  {
 148   4                      limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_50_PERCENT;
 149   4                  }
 150   3      
 151   3                  // flag_is_engine_unstable = 1;
 152   3              }
 153   2              else if (over_drive_status == 0)
 154   2              {
 155   3                  // æœªæ»¡è½½ pwm++
 156   3                  if (flag_is_pwm_add_time_comes) // pwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
 157   3                  {
 158   4                      flag_is_pwm_add_time_comes = 0;
 159   4                      if (limited_pwm_duty_due_to_unstable_engine < PWM_DUTY_100_PERCENT)
 160   4                      {
 161   5                          limited_pwm_duty_due_to_unstable_engine++;
 162   5                      }
 163   4                  }
 164   3              }
 165   2          }
C51 COMPILER V9.60.7.0   ENGINE                                                            01/26/2026 10:01:40 PAGE 4   

 166   1          else if (adc_pin_9_avg > (ADC_VAL_LOWER_THAN_170VAC) &&
 167   1                   (adc_pin_9_avg <= (ADC_VAL_170VAC) || flag_is_sub_power == 4)) // å°äº 170VAC
 168   1          {
 169   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 170   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 171   2              {
 172   3                  flag_is_pwm_sub_time_comes = 0;
 173   3      
 174   3                  if (flag_is_sub_power < 4)
 175   3                  {
 176   4                      flag_is_sub_power++;
 177   4                  }
 178   3      
 179   3                  flag_is_sub_power2 = 0;
 180   3                  flag_is_add_power = 0;
 181   3      
 182   3                  if (limited_pwm_duty_due_to_unstable_engine > PWM_DUTY_50_PERCENT)
 183   3                  {
 184   4                      limited_pwm_duty_due_to_unstable_engine -= 2;
 185   4      
 186   4                      // flag_is_engine_unstable = 1;
 187   4                  }
 188   3                  else if (limited_pwm_duty_due_to_unstable_engine < PWM_DUTY_50_PERCENT)
 189   3                  {
 190   4                      limited_pwm_duty_due_to_unstable_engine++;
 191   4                  }
 192   3                  else
 193   3                  {
 194   4                      limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_50_PERCENT;
 195   4                  }
 196   3              }
 197   2          }
 198   1          else if (adc_pin_9_avg <= (ADC_VAL_LOWER_THAN_170VAC) || (flag_is_sub_power2)) // å°äº 170VAC
 199   1          {
 200   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 201   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 202   2              {
 203   3                  flag_is_pwm_sub_time_comes = 0;
 204   3      
 205   3                  flag_is_sub_power2 = 1;
 206   3                  flag_is_sub_power = 0;
 207   3                  flag_is_add_power = 0;
 208   3      
 209   3                  if (limited_pwm_duty_due_to_unstable_engine > PWM_DUTY_30_PERCENT)
 210   3                  {
 211   4                      limited_pwm_duty_due_to_unstable_engine -= 2;
 212   4                  }
 213   3                  else
 214   3                  {
 215   4                      limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_30_PERCENT;
 216   4                  }
 217   3      
 218   3                  // flag_is_engine_unstable = 1;
 219   3              }
 220   2          }
 221   1      
 222   1          // if (flag_is_engine_unstable)
 223   1          // {
 224   1          //     /*
 225   1          //         å¦‚æœå‰é¢æ£€æµ‹åˆ°äº†å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®šï¼Œè¿™é‡Œç«‹å³æ›´æ–°pwmå ç©ºæ¯”
 226   1      
 227   1          //         å®é™…æµ‹è¯•è¿™ä¸ªä»£ç å—ç”¨æ—¶ 126 ~ 139 us
C51 COMPILER V9.60.7.0   ENGINE                                                            01/26/2026 10:01:40 PAGE 5   

 228   1          //     */
 229   1          //     // flag_is_engine_unstable = 0; // å±€éƒ¨å˜é‡ï¼Œåˆ°æœ€åå¯ä»¥ä¸æ¸…é›¶
 230   1          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 231   1          //     adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 232   1          //     cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty;
 233   1          //     cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty;
 234   1      
 235   1          //     set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
 236   1          //     set_pwm_channel_1_duty(cur_pwm_channel_1_duty);
 237   1          // }
 238   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    836    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    616       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
