C51 COMPILER V9.60.7.0   AD_KEY                                                            02/27/2026 17:14:56 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AD_KEY
OBJECT MODULE PLACED IN .\Release\Objects\ad_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\ad_key.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCD
                    -IR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\ad_key.lst) OBJECT(.\Rele
                    -ase\Objects\ad_key.obj)

line level    source

   1          #include "ad_key.h"
   2          #include "adc.h"
   3          
   4          // å­˜æ”¾æŒ‰é”®å¯¹åº”çš„adå€¼:
   5          static const u16 ad_key_scan_table[][2] = {
   6              // [][0]æŒ‰é”®å¯¹åº”çš„ç´¢å¼•,åœ¨åˆ¤æ–­æŒ‰é”®é”®å€¼æ—¶ä½¿ç”¨   [][1]æŒ‰é”®å¯¹åº”çš„adå€¼é˜ˆå€¼
   7          
   8              {AD_KEY_INDEX_1, AD_KEY_INDEX_1_VAL}, //
   9              {AD_KEY_INDEX_2, AD_KEY_INDEX_2_VAL}, //
  10              {AD_KEY_INDEX_3, AD_KEY_INDEX_3_VAL}, //
  11              {AD_KEY_INDEX_4, AD_KEY_INDEX_4_VAL}, //
  12          };
  13          
  14          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
  15          static const u8 ad_key_event_table[][AD_KEY_EFFECT_EVENT_NUMS + 1] = {
  16              {AD_KEY_INDEX_1, AD_KEY_EVENT_ID_1_CLICK, AD_KEY_EVENT_ID_1_LONG, AD_KEY_EVENT_ID_1_HOLD, AD_KEY_EVENT
             -_ID_1_LOOSE}, //
  17              {AD_KEY_INDEX_2, AD_KEY_EVENT_ID_2_CLICK, AD_KEY_EVENT_ID_2_LONG, AD_KEY_EVENT_ID_2_HOLD, AD_KEY_EVENT
             -_ID_2_LOOSE}, //
  18              {AD_KEY_INDEX_3, AD_KEY_EVENT_ID_3_CLICK, AD_KEY_EVENT_ID_3_LONG, AD_KEY_EVENT_ID_3_HOLD, AD_KEY_EVENT
             -_ID_3_LOOSE}, //
  19              {AD_KEY_INDEX_4, AD_KEY_EVENT_ID_4_CLICK, AD_KEY_EVENT_ID_4_LONG, AD_KEY_EVENT_ID_4_HOLD, AD_KEY_EVENT
             -_ID_4_LOOSE}, //
  20          };
  21          
  22          extern u8 ad_key_get_key_val(void);
  23          volatile struct key_driver_para ad_key_para = {
  24              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™
  25              AD_KEY_SCAN_CIRCLE_TIMES, // const u8 scan_times; // æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½ms
  26              0,                        // volatile u8 cur_scan_times; // æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®
             -šæ—¶å™¨ä¸­æ–­å†…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
  27              0,                        // volatile u8 last_key; // å­˜æ”¾ä¸Šä¸€æ¬¡è°ƒç”¨get_value()ä¹‹åå¾—åˆ°çš„æ
             -Œ‰é”®å€¼
  28          
  29              //== ç”¨äºæ¶ˆæŠ–ç±»å‚æ•° ==//
  30              0, // volatile u8 filter_value; // ç”¨äºæŒ‰é”®æ¶ˆæŠ–ï¼Œå­˜æ”¾æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼
  31              0, // volatile u8 filter_cnt;   // ç”¨äºæŒ‰é”®æ¶ˆæŠ–æ—¶çš„ç´¯åŠ å€¼
  32              3, // const u8 filter_time;     // å½“filter_cntç´¯åŠ åˆ°base_cntå€¼æ—¶, æ¶ˆæŠ–æœ‰æ•ˆ
  33          
  34              //== ç”¨äºåˆ¤å®šé•¿æŒ‰å’ŒHOLDäº‹ä»¶å‚æ•°
  35              AD_KEY_LONG_PRESS_TIME_THRESHOLD_MS / AD_KEY_SCAN_CIRCLE_TIMES,                                       
             -  // const u8 long_time; // æŒ‰é”®åˆ¤å®šé•¿æŒ‰æ•°é‡
  36              (AD_KEY_LONG_PRESS_TIME_THRESHOLD_MS + AD_KEY_HOLD_PRESS_TIME_THRESHOLD_MS) / AD_KEY_SCAN_CIRCLE_TIMES
             -, // const u8 hold_time; // æŒ‰é”®åˆ¤å®šHOLDæ•°é‡
  37              0,                                                                                                    
             -  // volatile u8 press_cnt; // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­long_eventå’Œhold_event
  38          
  39              //== ç”¨äºåˆ¤å®šè¿å‡»äº‹ä»¶å‚æ•°
  40              0,                  // volatile u8 click_cnt; // æŒ‰é”®æŒ‰ä¸‹æ¬¡æ•°
  41              0,                  // volatile u8 click_delay_cnt; // æŒ‰é”®è¢«æŠ¬èµ·åç­‰å¾…è¿å‡»äº‹ä»¶å»¶æ—¶è®¡æ•
             -°
  42              0,                  // const u8 click_delay_time; // æŒ‰é”®è¢«æŠ¬èµ·åç­‰å¾…è¿å‡»äº‹ä»¶å»¶æ—¶æ•°é‡
  43              0,                  // volatile u8 notify_value;    // åœ¨å»¶æ—¶çš„å¾…å‘é€æŒ‰é”®å€¼
C51 COMPILER V9.60.7.0   AD_KEY                                                            02/27/2026 17:14:56 PAGE 2   

  44              KEY_TYPE_AD,        // const u8 key_type;
  45              ad_key_get_key_val, // u8 (*get_value)(void); // ç”¨æˆ·è‡ªå®šä¹‰çš„è·å–é”®å€¼çš„å‡½æ•°
  46          
  47              // == å­˜æ”¾å¾—åˆ°çš„æŒ‰é”®é”®å€¼å’ŒæŒ‰é”®äº‹ä»¶
  48              AD_KEY_INDEX_NONE, // volatile u8 latest_key_val;
  49              KEY_EVENT_NONE,    // volatile u8 latest_key_event;
  50          };
  51          
  52          // å°†é‡‡é›†åˆ°çš„adå€¼è½¬æ¢æˆè‡ªå®šä¹‰çš„é”®å€¼
  53          
  54          static u16 ad_key_val_to_ad_key_index(const u16 ad_key_val)
  55          {
  56   1          u8 i = 0;
  57   1          u16 ad_key_index = NO_KEY;
  58   1      
  59   1          // ARRAY_SIZE(ad_key_scan_table) è¿™é‡Œæ˜¯æ±‚å‡ºæ•°ç»„ä¸­å­˜æ”¾çš„æŒ‰é”®ä¸ªæ•°
  60   1          for (i = 0; i < ARRAY_SIZE(ad_key_scan_table); i++)
  61   1          {
  62   2              if (ad_key_val < ad_key_scan_table[i][1])
  63   2              {
  64   3                  ad_key_index = ad_key_scan_table[i][0];
  65   3                  break;
  66   3              }
  67   2          }
  68   1      
  69   1          return ad_key_index;
  70   1      }
  71          
  72          //
  73          /**
  74           * @brief å°†æŒ‰é”®å€¼å’Œkey_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆadæŒ‰é”®çš„äº‹ä»¶
  75           *
  76           * @param key_val adæŒ‰é”®é”®å€¼
  77           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
  78           * @return u8 åœ¨ad_key_event_tableä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› AD_KEY_EVENT_
             -NONE
  79           */
  80          static u8 ad_key_get_event(const u8 key_val, const u8 key_event)
  81          {
  82   1          u8 ret_key_event = AD_KEY_EVENT_NONE;
  83   1          u8 key_event_index = 0;
  84   1          u8 i = 0;
  85   1      
  86   1          // å°† key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT è½¬æ¢ä¸º ad_key_event_table ä¸­çš„ç´¢å¼•
  87   1          if (key_event == KEY_EVENT_CLICK)
  88   1          {
  89   2              key_event_index = 1;
  90   2          }
  91   1          else if (key_event == KEY_EVENT_LONG)
  92   1          {
  93   2              key_event_index = 2;
  94   2          }
  95   1          else if (key_event == KEY_EVENT_HOLD)
  96   1          {
  97   2              key_event_index = 3;
  98   2          }
  99   1          else if (key_event == KEY_EVENT_UP)
 100   1          {
 101   2              key_event_index = 4;
 102   2          }
 103   1          else
 104   1          {
C51 COMPILER V9.60.7.0   AD_KEY                                                            02/27/2026 17:14:56 PAGE 3   

 105   2              return (u8)AD_KEY_EVENT_NONE;
 106   2          }
 107   1      
 108   1          for (; i < ARRAY_SIZE(ad_key_event_table); i++)
 109   1          {
 110   2              if (key_val == ad_key_event_table[i][0])
 111   2              {
 112   3                  ret_key_event = ad_key_event_table[i][key_event_index];
 113   3                  break;
 114   3              }
 115   2          }
 116   1      
 117   1          return ret_key_event;
 118   1      }
 119          
 120          // void adc_update_ad_key_val(u16 adc_val)
 121          // {
 122          //     adc_val_of_adkey = adc_val;
 123          // }
 124          
 125          // u16 adc_get_ad_key_val(void)
 126          // {
 127          //     return adc_val_of_adkey;
 128          // }
 129          
 130          // è·å–æŒ‰é”®é”®å€¼ï¼Œç”±key_driver_scan()å‡½æ•°è°ƒç”¨
 131          u8 ad_key_get_key_val(void)
 132          {
 133   1          static volatile u16 val = AD_KEY_NONE_VAL; // å•æ¬¡æŒ‰é”®æ ‡å¿—
 134   1          u8 ret = NO_KEY;
 135   1      
 136   1          // æœ‰æ•°æ®æ›´æ–°ï¼Œæ‰è·å–æ•°æ®
 137   1          if (adc_get_update_flag(ADC_CHANNEL_SEL_AD_KEY))
 138   1          {
 139   2              adc_clear_update_flag(ADC_CHANNEL_SEL_AD_KEY);
 140   2              val = adc_get_val(ADC_CHANNEL_SEL_AD_KEY);   
 141   2              
 142   2              // printf("ad key val == %u\n", val);
 143   2          }
 144   1      
 145   1          ret = ad_key_val_to_ad_key_index(val); // å°†é‡‡é›†åˆ°çš„adå€¼è½¬æ¢æˆè‡ªå®šä¹‰çš„é”®å€¼
 146   1          return ret;
 147   1      }
 148          
 149          void ad_key_handle(void)
 150          {
 151   1          u8 ad_key_event = AD_KEY_EVENT_NONE;
 152   1      
 153   1          if (ad_key_para.latest_key_val == AD_KEY_INDEX_NONE)
 154   1          {
 155   2              return;
 156   2          }
 157   1      
 158   1          ad_key_event = ad_key_get_event(ad_key_para.latest_key_val, ad_key_para.latest_key_event);
 159   1          ad_key_para.latest_key_val = AD_KEY_INDEX_NONE;
 160   1          ad_key_para.latest_key_event = KEY_EVENT_NONE;
 161   1      
 162   1          switch (ad_key_event)
 163   1          {
 164   2              // ================================================================
 165   2              // key 1ï¼Œå¯¹åº”çš„ä¸å°æ˜¯ ä¸Šä¸€æ›²
 166   2          case AD_KEY_EVENT_ID_1_CLICK:
C51 COMPILER V9.60.7.0   AD_KEY                                                            02/27/2026 17:14:56 PAGE 4   

 167   2              printf("key 1 click\n");
 168   2              break;
 169   2      
 170   2          case AD_KEY_EVENT_ID_1_LONG:
 171   2              printf("key 1 long\n");
 172   2              break;
 173   2      
 174   2          case AD_KEY_EVENT_ID_1_HOLD:
 175   2              printf("key 1 hold\n");
 176   2              break;
 177   2      
 178   2          case AD_KEY_EVENT_ID_1_LOOSE:
 179   2              printf("key 1 loose\n");
 180   2              break;
 181   2      
 182   2              // ================================================================
 183   2              // key 2ï¼Œå¯¹åº”çš„ä¸å°æ˜¯ ç¯å¼€å…³
 184   2          case AD_KEY_EVENT_ID_2_CLICK:
 185   2              printf("key 2 click\n");
 186   2              break;
 187   2      
 188   2          case AD_KEY_EVENT_ID_2_LONG:
 189   2              printf("key 2 long\n");
 190   2              break;
 191   2      
 192   2          case AD_KEY_EVENT_ID_2_HOLD:
 193   2              printf("key 2 hold\n");
 194   2              break;
 195   2      
 196   2          case AD_KEY_EVENT_ID_2_LOOSE:
 197   2              printf("key 2 loose\n");
 198   2              break;
 199   2      
 200   2              // ================================================================
 201   2              // key 3ï¼Œå¯¹åº”çš„ä¸å°æ˜¯ ä¸‹ä¸€æ›² 
 202   2      
 203   2          case AD_KEY_EVENT_ID_3_CLICK:
 204   2              printf("key 3 click\n");
 205   2              break;
 206   2      
 207   2          case AD_KEY_EVENT_ID_3_LONG:
 208   2              printf("key 3 long\n");
 209   2              break;
 210   2      
 211   2          case AD_KEY_EVENT_ID_3_HOLD:
 212   2              printf("key 3 hold\n");
 213   2              break;
 214   2      
 215   2          case AD_KEY_EVENT_ID_3_LOOSE:
 216   2              printf("key 3 loose\n");
 217   2              break;
 218   2      
 219   2              // ================================================================
 220   2              // key 4ï¼Œå¯¹åº”çš„ä¸å°æ˜¯ æ€»å¼€å…³ 
 221   2          case AD_KEY_EVENT_ID_4_CLICK:
 222   2              printf("key 4 click\n");
 223   2              break;
 224   2      
 225   2          case AD_KEY_EVENT_ID_4_LONG:
 226   2              printf("key 4 long\n");
 227   2              break;
 228   2      
C51 COMPILER V9.60.7.0   AD_KEY                                                            02/27/2026 17:14:56 PAGE 5   

 229   2          case AD_KEY_EVENT_ID_4_HOLD:
 230   2              printf("key 4 hold\n");
 231   2              break;
 232   2      
 233   2          case AD_KEY_EVENT_ID_4_LOOSE:
 234   2              printf("key 4 loose\n");
 235   2              break;
 236   2      
 237   2          default:
 238   2              break;
 239   2          }
 240   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    426    ----
   CONSTANT SIZE    =    200    ----
   XDATA SIZE       =     57       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
