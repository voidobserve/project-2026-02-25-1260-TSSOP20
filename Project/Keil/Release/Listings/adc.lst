C51 COMPILER V9.60.7.0   ADC                                                               02/26/2026 17:11:38 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          volatile u8 cur_adc_status = ADC_STATUS_IDLE;
   5          static volatile u16 adc_adkey_val = 0;
   6          static volatile bit flag_is_adkey_val_update = 0;
   7          static volatile u16 adc_bat_det_val = 0;
   8          static volatile bit flag_is_adc_bat_det_val_update = 0;
   9          
  10          // adcç›¸å…³çš„å¼•è„šé…ç½®
  11          void adc_pin_init(void)
  12          {
  13   1          // P24 æ£€æµ‹ADKEY
  14   1          P2_MD1 |= GPIO_P24_MODE_SEL(0x3);
  15   1      }
  16          
  17          void adc_init(void)
  18          {
  19   1          // ADCé…ç½®
  20   1          ADC_ACON1 &= ~(ADC_VREF_SEL(0x07) |  // æ¸…ç©ºå‚è€ƒç”µå‹é€‰æ‹©ä½
  21   1                         ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
  22   1                         ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
  23   1          ADC_ACON1 |= ADC_VREF_SEL(0x06) |    // é€‰æ‹© VCC ä½œä¸ºå‚è€ƒç”µå‹
  24   1                       ADC_TEN_SEL(0x03);      // å…³é—­æµ‹è¯•ä¿¡å·
  25   1      
  26   1          ADC_ACON0 = ADC_CMP_EN(0x1) |  // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  27   1                      ADC_BIAS_EN(0x1) | // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  28   1                      ADC_BIAS_SEL(0x1); // æ‰“å¼€ ADCåç½®ç”µæµ
  29   1      
  30   1          __EnableIRQ(ADC_IRQn); // ä½¿èƒ½ADCä¸­æ–­
  31   1          IE_EA = 1;             // ä½¿èƒ½æ€»ä¸­æ–­
  32   1      
  33   1          ADC_CFG1 |= (0x0F << 3) |       // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16ï¼ˆæŠŠadcæ—¶é’Ÿè®¾ç½
             -®ä¸ºæœ€æ…¢ï¼Œï¼‰
  34   1                      (0x01 << 0);        // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
  35   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½ é€šé“0
  36   1                      ADC_EN(0x1);        // ä½¿èƒ½ adc
  37   1      
  38   1          delay_ms(1); // ç­‰å¾…ADCæ¨¡å—é…ç½®ç¨³å®šï¼Œéœ€è¦ç­‰å¾…20usä»¥ä¸Š
  39   1      }
  40          
  41          /**
  42           * @brief æ›´æ–°é€šé“å¯¹åº”çš„adå€¼ï¼ˆç”±adä¸­æ–­æ›´æ–°ï¼‰
  43           *
  44           * @param adc_channel
  45           * @param adc_val
  46           */
  47          void adc_update_val(adc_channel_sel_t adc_channel, u16 adc_val)
  48          {
  49   1          switch (adc_channel)
  50   1          {
  51   2          case ADC_CHANNEL_SEL_AD_KEY:
  52   2              adc_adkey_val = adc_val;
C51 COMPILER V9.60.7.0   ADC                                                               02/26/2026 17:11:38 PAGE 2   

  53   2              flag_is_adkey_val_update = 1;
  54   2              break;
  55   2          case ADC_CHANNEL_SEL_BAT_DET:
  56   2              adc_bat_det_val = adc_val;
  57   2              flag_is_adc_bat_det_val_update = 1;
  58   2              break;
  59   2          }
  60   1      }
  61          
  62          u16 adc_get_val(adc_channel_sel_t adc_channel)
  63          {
  64   1          u16 ret = 0;
  65   1          switch (adc_channel)
  66   1          {
  67   2          case ADC_CHANNEL_SEL_AD_KEY:
  68   2              ret = adc_adkey_val;
  69   2              break;
  70   2          case ADC_CHANNEL_SEL_BAT_DET:
  71   2              ret = adc_bat_det_val;
  72   2              break;
  73   2          default:
  74   2              break;
  75   2          }
  76   1      
  77   1          return ret;
  78   1      }
  79          
  80          // è·å–æ›´æ–°æ ‡å¿—ä½çš„çŠ¶æ€
  81          u8 adc_get_update_flag(adc_channel_sel_t adc_channel)
  82          {
  83   1          u8 ret = 0xFF;
  84   1          switch (adc_channel)
  85   1          {
  86   2          case ADC_CHANNEL_SEL_AD_KEY:
  87   2              ret = (u8)flag_is_adkey_val_update;
  88   2              break;
  89   2          case ADC_CHANNEL_SEL_BAT_DET:
  90   2              ret = (u8)flag_is_adc_bat_det_val_update;
  91   2              break;
  92   2      
  93   2          default:
  94   2              break;
  95   2          }
  96   1      
  97   1          return ret;
  98   1      }
  99          
 100          // æ¸…é™¤æ›´æ–°æ ‡å¿—ä½çš„çŠ¶æ€
 101          void adc_clear_update_flag(adc_channel_sel_t adc_channel)
 102          {
 103   1          switch (adc_channel)
 104   1          {
 105   2          case ADC_CHANNEL_SEL_AD_KEY:
 106   2              flag_is_adkey_val_update = 0;
 107   2              break;
 108   2          case ADC_CHANNEL_SEL_BAT_DET:
 109   2              flag_is_adc_bat_det_val_update = 0;
 110   2              break;
 111   2      
 112   2          default:
 113   2              break;
 114   2          }
C51 COMPILER V9.60.7.0   ADC                                                               02/26/2026 17:11:38 PAGE 3   

 115   1      }
 116          
 117          void adc_channel_sel(adc_channel_sel_t adc_channel)
 118          {
 119   1          switch (adc_channel)
 120   1          {
 121   2          case ADC_CHANNEL_SEL_AD_KEY:
 122   2              // ADCé…ç½®
 123   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x07) |  // æ¸…ç©ºå‚è€ƒç”µå‹é€‰æ‹©ä½
 124   2                             ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
 125   2                             ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
 126   2              ADC_ACON1 |= ADC_VREF_SEL(0x06) |    // é€‰æ‹© VCC ä½œä¸ºå‚è€ƒç”µå‹
 127   2                           ADC_TEN_SEL(0x03);      // å…³é—­æµ‹è¯•ä¿¡å·
 128   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x14);    // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x14--P24ï¼‰
 129   2              break;
 130   2          case ADC_CHANNEL_SEL_BAT_DET:
 131   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x07) |  // æ¸…ç©ºå‚è€ƒç”µå‹é€‰æ‹©ä½
 132   2                             ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
 133   2                             ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
 134   2              ADC_ACON1 |= ADC_VREF_SEL(0x01) |    // é€‰æ‹© å†…éƒ¨2.0V ä½œä¸ºå‚è€ƒç”µå‹
 135   2                           ADC_TEN_SEL(0x03) |     // å…³é—­æµ‹è¯•ä¿¡å·
 136   2                           ADC_INREF_SEL(0x01);    // ä½¿èƒ½å†…éƒ¨å‚è€ƒç”µå‹
 137   2              ADC_CHS0 = ADC_EXT_SEL(0x01) |       // é€‰æ‹©å†…éƒ¨é€šé“
 138   2                         ADC_ANALOG_CHAN(0x03);    // é€‰æ‹© VDD 1/5åˆ†å‹çš„é€šé“
 139   2              break;
 140   2      
 141   2          default:
 142   2              break;
 143   2          }
 144   1      
 145   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0
 146   1                      ADC_EN(0x1);        // ä½¿èƒ½adc
 147   1      }
 148          
 149          // ç”±1msåŠä»¥ä¸Šçš„å®šæ—¶å™¨è°ƒç”¨
 150          void adc_scan(void)
 151          {
 152   1          if (ADC_STATUS_IDLE == cur_adc_status ||
 153   1              ADC_STATUS_SEL_BAT_DET == cur_adc_status)
 154   1          {
 155   2              adc_channel_sel(ADC_CHANNEL_SEL_AD_KEY);
 156   2              cur_adc_status = ADC_STATUS_SEL_AD_KEY_WAITING;
 157   2          }
 158   1          else if (ADC_STATUS_SEL_AD_KEY_WAITING == cur_adc_status)
 159   1          {
 160   2              // å¼€å¯è½¬æ¢ï¼Œä¹‹ååœ¨adä¸­æ–­è·å–adå€¼
 161   2              ADC_CFG0 |= 0x01 << 0; // å¼€å¯ adc0 è½¬æ¢
 162   2              cur_adc_status = ADC_STATUS_SEL_AD_KEY;
 163   2          }
 164   1          else if (ADC_STATUS_SEL_AD_KEY == cur_adc_status)
 165   1          {
 166   2              adc_channel_sel(ADC_CHANNEL_SEL_BAT_DET);
 167   2              cur_adc_status = ADC_STATUS_SEL_BAT_DET_WAITING;
 168   2          }
 169   1          else if (ADC_STATUS_SEL_BAT_DET_WAITING == cur_adc_status)
 170   1          {
 171   2              // å¼€å¯è½¬æ¢ï¼Œä¹‹ååœ¨adä¸­æ–­è·å–adå€¼
 172   2              ADC_CFG0 |= 0x01 << 0; // å¼€å¯ adc0 è½¬æ¢
 173   2              cur_adc_status = ADC_STATUS_SEL_BAT_DET;
 174   2          }
 175   1      }
 176          
C51 COMPILER V9.60.7.0   ADC                                                               02/26/2026 17:11:38 PAGE 4   

 177          void ADC_IRQHandler(void) interrupt ADC_IRQn
 178          {
 179   1          volatile u16 adc_val;
 180   1      
 181   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 182   1          __IRQnIPnPush(ADC_IRQn);
 183   1      
 184   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 185   1      
 186   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
 187   1          {
 188   2              adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // å…ˆæ¥æ”¶adå€¼
 189   2              if (ADC_STATUS_SEL_AD_KEY == cur_adc_status)
 190   2              {
 191   3                  adc_update_val(ADC_CHANNEL_SEL_AD_KEY, adc_val);
 192   3              }
 193   2              else if (ADC_STATUS_SEL_BAT_DET == cur_adc_status)
 194   2              {
 195   3                  adc_update_val(ADC_CHANNEL_SEL_BAT_DET, adc_val);
 196   3              }
 197   2      
 198   2              ADC_STA |= ADC_CHAN0_DONE(0x01); // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 199   2          }
 200   1      
 201   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 202   1          __IRQnIPnPop(ADC_IRQn);
 203   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    375    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
