C51 COMPILER V9.60.7.0   ADC                                                               02/28/2026 14:59:52 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "user_config.h"
   3          
   4          volatile u8 cur_adc_status = ADC_STATUS_IDLE;
   5          
   6          // adæŒ‰é”®ï¼š
   7          static volatile u16 adc_adkey_val = 0; // å­˜æ”¾é‡‡é›†åˆ°çš„adå€¼
   8          static volatile bit flag_is_adkey_val_update = 0;
   9          // adç”µæ± ï¼š
  10          static volatile u16 adc_bat_det_val = 0;
  11          static volatile bit flag_is_adc_bat_det_val_update = 0;
  12          // adå¤ªé˜³èƒ½ï¼š
  13          static volatile u16 adc_solar_det_val = 0;
  14          static volatile bit flag_is_adc_solar_det_val_update = 0;
  15          
  16          // adcç›¸å…³çš„å¼•è„šé…ç½®
  17          void adc_pin_init(void)
  18          {
  19   1          // P24 æ£€æµ‹ADKEY
  20   1          P2_MD1 |= GPIO_P24_MODE_SEL(0x3);
  21   1      
  22   1          // P14 æ£€æµ‹å¤ªé˜³èƒ½ä¸€ä¾§çš„ç”µå‹
  23   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x3);
  24   1      }
  25          
  26          void adc_init(void)
  27          {
  28   1          // ADCé…ç½®
  29   1          // ADC_ACON1 &= ~(ADC_VREF_SEL(0x07) |  // æ¸…ç©ºå‚è€ƒç”µå‹é€‰æ‹©ä½
  30   1          //                ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
  31   1          //                ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
  32   1          // ADC_ACON1 |= ADC_VREF_SEL(0x06) |    // é€‰æ‹© VCC ä½œä¸ºå‚è€ƒç”µå‹
  33   1          //              ADC_TEN_SEL(0x03);      // å…³é—­æµ‹è¯•ä¿¡å·
  34   1      
  35   1          ADC_ACON0 = ADC_CMP_EN(0x1) |  // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  36   1                      ADC_BIAS_EN(0x1) | // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  37   1                      ADC_BIAS_SEL(0x1); // æ‰“å¼€ ADCåç½®ç”µæµ
  38   1      
  39   1          __EnableIRQ(ADC_IRQn); // ä½¿èƒ½ADCä¸­æ–­
  40   1          IE_EA = 1;             // ä½¿èƒ½æ€»ä¸­æ–­
  41   1      
  42   1          ADC_CFG1 |= (0x0F << 3) |       // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16ï¼ˆæŠŠadcæ—¶é’Ÿè®¾ç½
             -®ä¸ºæœ€æ…¢ï¼Œï¼‰
  43   1                      (0x01 << 0);        // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
  44   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½ é€šé“0
  45   1                      ADC_EN(0x1);        // ä½¿èƒ½ adc
  46   1      
  47   1          delay_ms(1); // ç­‰å¾…ADCæ¨¡å—é…ç½®ç¨³å®šï¼Œéœ€è¦ç­‰å¾…20usä»¥ä¸Š
  48   1      }
  49          
  50          /**
  51           * @brief æ›´æ–°é€šé“å¯¹åº”çš„adå€¼ï¼ˆç”±adä¸­æ–­æ›´æ–°ï¼‰
  52           *
C51 COMPILER V9.60.7.0   ADC                                                               02/28/2026 14:59:52 PAGE 2   

  53           * @param adc_channel
  54           * @param adc_val
  55           */
  56          void adc_update_val(adc_channel_sel_t adc_channel, u16 adc_val)
  57          {
  58   1          switch (adc_channel)
  59   1          {
  60   2          case ADC_CHANNEL_SEL_AD_KEY:
  61   2              adc_adkey_val = adc_val;
  62   2              flag_is_adkey_val_update = 1;
  63   2              break;
  64   2          case ADC_CHANNEL_SEL_BAT_DET:
  65   2              adc_bat_det_val = adc_val;
  66   2              flag_is_adc_bat_det_val_update = 1;
  67   2              break;
  68   2          case ADC_CHANNEL_SEL_SOLAR_DET:
  69   2              adc_solar_det_val = adc_val;
  70   2              flag_is_adc_solar_det_val_update = 1;
  71   2              break;
  72   2          }
  73   1      }
  74          
  75          u16 adc_get_val(adc_channel_sel_t adc_channel)
  76          {
  77   1          u16 ret = 0;
  78   1          switch (adc_channel)
  79   1          {
  80   2          case ADC_CHANNEL_SEL_AD_KEY:
  81   2              ret = adc_adkey_val;
  82   2              break;
  83   2          case ADC_CHANNEL_SEL_BAT_DET:
  84   2              ret = adc_bat_det_val;
  85   2              break;
  86   2          case ADC_CHANNEL_SEL_SOLAR_DET:
  87   2              ret = adc_solar_det_val;
  88   2              break;
  89   2      
  90   2          default:
  91   2              break;
  92   2          }
  93   1      
  94   1          return ret;
  95   1      }
  96          
  97          // è·å–æ›´æ–°æ ‡å¿—ä½çš„çŠ¶æ€
  98          u8 adc_get_update_flag(adc_channel_sel_t adc_channel)
  99          {
 100   1          u8 ret = 0xFF;
 101   1          switch (adc_channel)
 102   1          {
 103   2          case ADC_CHANNEL_SEL_AD_KEY:
 104   2              ret = (u8)flag_is_adkey_val_update;
 105   2              break;
 106   2          case ADC_CHANNEL_SEL_BAT_DET:
 107   2              ret = (u8)flag_is_adc_bat_det_val_update;
 108   2              break;
 109   2          case ADC_CHANNEL_SEL_SOLAR_DET:
 110   2              ret = (u8)flag_is_adc_solar_det_val_update;
 111   2              break;
 112   2      
 113   2          default:
 114   2              break;
C51 COMPILER V9.60.7.0   ADC                                                               02/28/2026 14:59:52 PAGE 3   

 115   2          }
 116   1      
 117   1          return ret;
 118   1      }
 119          
 120          // æ¸…é™¤æ›´æ–°æ ‡å¿—ä½çš„çŠ¶æ€
 121          void adc_clear_update_flag(adc_channel_sel_t adc_channel)
 122          {
 123   1          switch (adc_channel)
 124   1          {
 125   2          case ADC_CHANNEL_SEL_AD_KEY:
 126   2              flag_is_adkey_val_update = 0;
 127   2              break;
 128   2          case ADC_CHANNEL_SEL_BAT_DET:
 129   2              flag_is_adc_bat_det_val_update = 0;
 130   2              break;
 131   2          case ADC_CHANNEL_SEL_SOLAR_DET:
 132   2              flag_is_adc_solar_det_val_update = 0;
 133   2              break;
 134   2      
 135   2          default:
 136   2              break;
 137   2          }
 138   1      }
 139          
 140          void adc_channel_sel(adc_channel_sel_t adc_channel)
 141          {
 142   1          ADC_ACON1 &= ~(ADC_VREF_SEL(0x07) |  // æ¸…ç©ºå‚è€ƒç”µå‹é€‰æ‹©ä½
 143   1                         ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
 144   1                         ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
 145   1      
 146   1          switch (adc_channel)
 147   1          {
 148   2          case ADC_CHANNEL_SEL_AD_KEY:
 149   2              // ADCé…ç½®
 150   2              ADC_ACON1 |= ADC_VREF_SEL(0x06) | // é€‰æ‹© VCC ä½œä¸ºå‚è€ƒç”µå‹
 151   2                           ADC_TEN_SEL(0x03);   // å…³é—­æµ‹è¯•ä¿¡å·
 152   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x14); // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x14--P24ï¼‰
 153   2              break;
 154   2          case ADC_CHANNEL_SEL_BAT_DET:
 155   2              ADC_ACON1 |= ADC_VREF_SEL(0x01) | // é€‰æ‹© å†…éƒ¨2.0V ä½œä¸ºå‚è€ƒç”µå‹
 156   2                           ADC_TEN_SEL(0x03) |  // å…³é—­æµ‹è¯•ä¿¡å·
 157   2                           ADC_INREF_SEL(0x01); // ä½¿èƒ½å†…éƒ¨å‚è€ƒç”µå‹
 158   2              ADC_CHS0 = ADC_EXT_SEL(0x01) |    // é€‰æ‹©å†…éƒ¨é€šé“
 159   2                         ADC_ANALOG_CHAN(0x03); // é€‰æ‹© VDD 1/5 åˆ†å‹çš„é€šé“
 160   2              break;
 161   2          case ADC_CHANNEL_SEL_SOLAR_DET:
 162   2              //  0 ~ 5 Vï¼Œ ç»è¿‡äºŒæç®¡0.3Våï¼Œå®é™…çš„å……ç”µç”µå‹èŒƒå›´ï¼š0 ~ 4.7V
 163   2              // ç»è¿‡ 1/2 åˆ†å‹åï¼Œå•ç‰‡æœºæ£€æµ‹åˆ°çš„ç”µå‹èŒƒå›´ï¼š0 ~ 2.35V
 164   2              // ä½¿ç”¨2.4Vå‚è€ƒç”µå‹ 
 165   2              ADC_ACON1 |= ADC_VREF_SEL(0x02) | // é€‰æ‹© å†…éƒ¨2.4V ä½œä¸ºå‚è€ƒç”µå‹
 166   2                           ADC_TEN_SEL(0x03) |  // å…³é—­æµ‹è¯•ä¿¡å·
 167   2                           ADC_INREF_SEL(0x01); // ä½¿èƒ½å†…éƒ¨å‚è€ƒç”µå‹
 168   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x0C); // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0C -- P14ï¼‰
 169   2              break;
 170   2      
 171   2          default:
 172   2              break;
 173   2          }
 174   1      
 175   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0
 176   1                      ADC_EN(0x1);        // ä½¿èƒ½adc
C51 COMPILER V9.60.7.0   ADC                                                               02/28/2026 14:59:52 PAGE 4   

 177   1      }
 178          
 179          // ç”±1msåŠä»¥ä¸Šçš„å®šæ—¶å™¨è°ƒç”¨
 180          void adc_scan(void)
 181          {
 182   1          if (ADC_STATUS_IDLE == cur_adc_status ||
 183   1              ADC_STATUS_SEL_SOLAR_DET == cur_adc_status)
 184   1          {
 185   2              adc_channel_sel(ADC_CHANNEL_SEL_AD_KEY);
 186   2              cur_adc_status = ADC_STATUS_SEL_AD_KEY_WAITING;
 187   2          }
 188   1          else if (ADC_STATUS_SEL_AD_KEY_WAITING == cur_adc_status)
 189   1          {
 190   2              // å¼€å¯è½¬æ¢ï¼Œä¹‹ååœ¨adä¸­æ–­è·å–adå€¼
 191   2              ADC_CFG0 |= 0x01 << 0; // å¼€å¯ adc0 è½¬æ¢
 192   2              cur_adc_status = ADC_STATUS_SEL_AD_KEY;
 193   2          }
 194   1          else if (ADC_STATUS_SEL_AD_KEY == cur_adc_status)
 195   1          {
 196   2              adc_channel_sel(ADC_CHANNEL_SEL_BAT_DET);
 197   2              cur_adc_status = ADC_STATUS_SEL_BAT_DET_WAITING;
 198   2          }
 199   1          else if (ADC_STATUS_SEL_BAT_DET_WAITING == cur_adc_status)
 200   1          {
 201   2              // å¼€å¯è½¬æ¢ï¼Œä¹‹ååœ¨adä¸­æ–­è·å–adå€¼
 202   2              ADC_CFG0 |= 0x01 << 0; // å¼€å¯ adc0 è½¬æ¢
 203   2              cur_adc_status = ADC_STATUS_SEL_BAT_DET;
 204   2          }
 205   1          else if (ADC_STATUS_SEL_BAT_DET == cur_adc_status)
 206   1          {
 207   2              adc_channel_sel(ADC_CHANNEL_SEL_SOLAR_DET);
 208   2              cur_adc_status = ADC_STATUS_SEL_SOLAR_DET_WAITING;
 209   2          }
 210   1          else if (ADC_STATUS_SEL_SOLAR_DET_WAITING == cur_adc_status)
 211   1          {
 212   2              // å¼€å¯è½¬æ¢ï¼Œä¹‹ååœ¨adä¸­æ–­è·å–adå€¼
 213   2              ADC_CFG0 |= 0x01 << 0; // å¼€å¯ adc0 è½¬æ¢
 214   2              cur_adc_status = ADC_STATUS_SEL_SOLAR_DET;
 215   2          }
 216   1      }
 217          
 218          void ADC_IRQHandler(void) interrupt ADC_IRQn
 219          {
 220   1          volatile u16 adc_val;
 221   1      
 222   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 223   1          __IRQnIPnPush(ADC_IRQn);
 224   1      
 225   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 226   1      
 227   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
 228   1          {
 229   2              adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // å…ˆæ¥æ”¶adå€¼
 230   2              if (ADC_STATUS_SEL_AD_KEY == cur_adc_status)
 231   2              {
 232   3                  adc_update_val(ADC_CHANNEL_SEL_AD_KEY, adc_val);
 233   3              }
 234   2              else if (ADC_STATUS_SEL_BAT_DET == cur_adc_status)
 235   2              {
 236   3                  adc_update_val(ADC_CHANNEL_SEL_BAT_DET, adc_val);
 237   3              }
 238   2              else if (ADC_STATUS_SEL_SOLAR_DET == cur_adc_status)
C51 COMPILER V9.60.7.0   ADC                                                               02/28/2026 14:59:52 PAGE 5   

 239   2              {
 240   3                  adc_update_val(ADC_CHANNEL_SEL_SOLAR_DET, adc_val);
 241   3              }
 242   2      
 243   2              ADC_STA |= ADC_CHAN0_DONE(0x01); // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 244   2          }
 245   1      
 246   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 247   1          __IRQnIPnPop(ADC_IRQn);
 248   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    475    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
