C51 COMPILER V9.60.7.0   UART_DATA_HANDLE                                                  02/26/2026 17:15:59 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART_DATA_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\uart_data_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\uart_data_handle.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\uart_data_handl
                    -e.lst) OBJECT(.\Release\Objects\uart_data_handle.obj)

line level    source

   1          #include "uart_data_handle.h"
   2          #include "my_config.h"
   3          #include "uart0.h" 
   4          
   5          
   6          #include <stdio.h> // printf
   7          
   8          static volatile u8 cmd_buff[10] = {0};    // Â≠òÊîæÊé•Êî∂Âà∞ÁöÑ‰∏ÄÊù°Êåá‰ª§
   9          static volatile u8 cur_cmd_buff_len = 0;  // ÊåáÁ§∫ÂΩìÂâçÊé•Êî∂Âà∞ÁöÑÊåá‰ª§ÁöÑÁ¥¢ÂºïÔºà‰πãÂêé‰ºöÂú®Á®ãÂ∫è‰
             -∏≠Êõ¥Êñ∞Ôºå‰∏çÁî®Ê∏ÖÈõ∂Ôºâ
  10          static volatile u8 dest_cmd_buff_len = 0; // Â≠òÊîæÊúÄÁªàË¶ÅÊé•Êî∂ÁöÑÊåá‰ª§ÈïøÂ∫¶Ôºà‰πãÂêé‰ºöÂú®Á®ãÂ∫è‰∏≠Ê
             -õ¥Êñ∞Ôºå‰∏çÁî®Ê∏ÖÈõ∂Ôºâ
  11          
  12          static volatile u8 timeout_enable = 0; // Ë∂ÖÊó∂ËÆ°Êï∞‰ΩøËÉΩ
  13          static volatile u16 timeout_cnt = 0;   // Ë∂ÖÊó∂ËÆ°Êï∞
  14          
  15          // Áî±ÂÆöÊó∂‰∏≠Êñ≠Ë∞ÉÁî®ÔºåÁ¥ØËÆ°Ë∂ÖÊó∂ËÆ°Êï∞
  16          void uart_data_recv_timeout_add(void)
  17          {
  18   1          if (timeout_enable)
  19   1          {
  20   2              timeout_cnt += 10; // ÊúâËÆ°Êï∞Ê∫¢Âá∫ÁöÑÈ£éÈô©ÔºåË¶ÅÊ≥®ÊÑèÂú®Ê∫¢Âá∫ÂâçËøõË°åÂ§ÑÁêÜ
  21   2          }
  22   1      }
  23          
  24          void uart_data_handle(void)
  25          {
  26   1          static volatile u8 uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE; // Áä∂ÊÄÅÊú∫
  27   1      
  28   1          u8 recv_byte;
  29   1          u8 check_sum = 0;        // Â≠òÊîæËÆ°ÁÆó‰πãÂêéÁöÑÊ†°È™åÂíå
  30   1          u8 i;                    // Âæ™ÁéØËÆ°Êï∞ÂÄº
  31   1          u8 is_recv_complete = 0; // ÊòØÂê¶Êé•Êî∂Âà∞ÂÆåÊï¥ÁöÑ‰∏ÄÂ∏ßÊåá‰ª§
  32   1      
  33   1          if (0 == uart0_rxbuffer_get_count())
  34   1          {
  35   2              // Êú™Êî∂Âà∞Êï∞ÊçÆÔºåÁ¥ØÂä†Ë∂ÖÊó∂ËÆ°Êó∂
  36   2              if (timeout_cnt >= UART_DATA_HANDLE_TIMEOUT)
  37   2              {
  38   3                  // Êé•Êî∂Ë∂ÖÊó∂
  39   3                  timeout_cnt = 0;
  40   3                  timeout_enable = 0;                                     // ‰∏ç‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
  41   3                  uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE; // ÈáçÊñ∞ÂºÄÂßãÊé•Êî∂
  42   3      
  43   3                  // ÊâìÂç∞Ë∂ÖÊó∂‰πãÂêéÔºåÁºìÂÜ≤Âå∫ÂÜÖÁöÑÊï∞ÊçÆ
  44   3                  printf("=================================>\n");
  45   3                  printf("uart recv timeout\n");
  46   3                  for (i = 0; i < ARRAY_SIZE(cmd_buff); i++)
  47   3                  {
  48   4                      printf("%02x", (u16)cmd_buff[i]);
  49   4                  }
  50   3                  printf("=================================^\n");
  51   3              }
C51 COMPILER V9.60.7.0   UART_DATA_HANDLE                                                  02/26/2026 17:15:59 PAGE 2   

  52   2      
  53   2              return; // ‰∏≤Âè£ÁºìÂÜ≤Âå∫ÁöÑÊï∞ÊçÆ‰∏∫Á©∫ÔºåÁõ¥Êé•ËøîÂõû
  54   2          }
  55   1      
  56   1          while (1) // ‰∏ÄÊ¨°ÊÄßÊääÁºìÂÜ≤Âå∫‰∏≠ÁöÑÊï∞ÊçÆËØªÂá∫Êù•
  57   1          {
  58   2              if (uart0_rxbuffer_get_count() == 0 || is_recv_complete) // ÈÄÄÂá∫Êù°‰ª∂
  59   2              {
  60   3                  if (is_recv_complete)
  61   3                  {
  62   4                      is_recv_complete = 0;
  63   4                  }
  64   3      
  65   3                  break;
  66   3              }
  67   2      
  68   2              timeout_enable = 1; // ‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
  69   2              timeout_cnt = 0;
  70   2              recv_byte = uart0_rxbuffer_get_byte();
  71   2      
  72   2              switch (uart_data_handle_status)
  73   2              {
  74   3              case UART_DATA_HANDLE_STATUS_FORMAT_HEAD0:
  75   3                  if (UART_DATA_HANDLE_FORMAT_HEAD0 == recv_byte)
  76   3                  {
  77   4                      cmd_buff[0] = recv_byte;
  78   4                      uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_HEAD1;
  79   4                  }
  80   3                  break;
  81   3              case UART_DATA_HANDLE_STATUS_FORMAT_HEAD1:
  82   3                  if (UART_DATA_HANDLE_FORMAT_HEAD1 == recv_byte)
  83   3                  {
  84   4                      cmd_buff[1] = recv_byte;
  85   4                      uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_FIX_VAL0;
  86   4                  }
  87   3                  else
  88   3                  {
  89   4                      // Â¶ÇÊûúÊï∞ÊçÆÊúâËØØÔºåÈáçÊñ∞ÂºÄÂßãÊé•Êî∂
  90   4                      uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_HEAD0;
  91   4                  }
  92   3                  break;
  93   3              case UART_DATA_HANDLE_STATUS_FORMAT_FIX_VAL0:
  94   3                  if (UART_DATA_HANDLE_FORMAT_FIX_VAL0 == recv_byte)
  95   3                  {
  96   4                      cmd_buff[2] = recv_byte;
  97   4                      uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_CMD;
  98   4                  }
  99   3                  else
 100   3                  {
 101   4                      // Â¶ÇÊûúÊï∞ÊçÆÊúâËØØÔºåÈáçÊñ∞ÂºÄÂßãÊé•Êî∂
 102   4                      uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_HEAD0;
 103   4                  }
 104   3      
 105   3                  break;
 106   3              case UART_DATA_HANDLE_STATUS_FORMAT_CMD:
 107   3                  cmd_buff[3] = recv_byte;
 108   3                  uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_DATA;
 109   3                  break;
 110   3              }
 111   2          }
 112   1      
 113   1          if (UART_DATA_HANDLE_STATUS_FORMAT_TAIL != uart_data_handle_status)
C51 COMPILER V9.60.7.0   UART_DATA_HANDLE                                                  02/26/2026 17:15:59 PAGE 3   

 114   1          {
 115   2              return; // Êú™Êé•Êî∂ÂÆåÊï∞ÊçÆÔºå‰∏çËøõÂÖ•‰∏ãÈù¢ÁöÑÂ§ÑÁêÜÊìç‰ΩúÔºåÂáΩÊï∞Áõ¥Êé•ËøîÂõû
 116   2          }
 117   1      
 118   1          // ÊâìÂç∞Êé•Êî∂Âà∞ÁöÑ‰∏ÄÂ∏ßÊï∞ÊçÆ
 119   1          for (i = 0; i < dest_cmd_buff_len; i++)
 120   1          {
 121   2              printf("0x%02x ", (u16)cmd_buff[i]);
 122   2          }
 123   1          printf("\n");
 124   1      
 125   1          switch (cmd_buff[2])
 126   1          {
 127   2      
 128   2          default:
 129   2              break;
 130   2          }
 131   1      
 132   1          // Â§ÑÁêÜÂÆåÊàêÂêéÔºåÈáçÊñ∞Êé•Êî∂Êï∞ÊçÆ
 133   1          timeout_cnt = 0;
 134   1          timeout_enable = 0; // ‰∏ç‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
 135   1          uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE;
 136   1      
 137   1      #if 0
                  static volatile u8 cmd_buff[10] = {0};    // Â≠òÊîæÊé•Êî∂Âà∞ÁöÑ‰∏ÄÊù°Êåá‰ª§
                  static volatile u8 cur_cmd_buff_len = 0;  // ÊåáÁ§∫ÂΩìÂâçÊé•Êî∂Âà∞ÁöÑÊåá‰ª§ÁöÑÁ¥¢ÂºïÔºà‰πãÂêé‰ºöÂú®Á®ã
             -Â∫è‰∏≠Êõ¥Êñ∞Ôºå‰∏çÁî®Ê∏ÖÈõ∂Ôºâ
                  static volatile u8 dest_cmd_buff_len = 0; // Â≠òÊîæÊúÄÁªàË¶ÅÊé•Êî∂ÁöÑÊåá‰ª§ÈïøÂ∫¶Ôºà‰πãÂêé‰ºöÂú®Á®ãÂ∫è
             -‰∏≠Êõ¥Êñ∞Ôºå‰∏çÁî®Ê∏ÖÈõ∂Ôºâ
              
                  static volatile u8 timeout_enable = 0; // Ë∂ÖÊó∂ËÆ°Êï∞‰ΩøËÉΩ
                  static volatile u32 timeout_cnt = 0;   // Ë∂ÖÊó∂ËÆ°Êï∞ÔºàÂü∫‰∫éÁ≥ªÁªüÊó∂Âü∫ÔºåËøêË°åÊó∂ÂÄº‰∏ç‰∏∫0Ôºâ
              
                  static volatile u8 uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE; // Áä∂ÊÄÅÊú∫
              
                  u8 recv_byte;
                  u8 check_sum = 0;        // Â≠òÊîæËÆ°ÁÆó‰πãÂêéÁöÑÊ†°È™åÂíå
                  u8 i;                    // Âæ™ÁéØËÆ°Êï∞ÂÄº
                  u8 is_recv_complete = 0; // ÊòØÂê¶Êé•Êî∂Âà∞ÂÆåÊï¥ÁöÑ‰∏ÄÂ∏ßÊåá‰ª§
              
                  // Êé•Êî∂Ë∂ÖÊó∂Â§ÑÁêÜÔºö
                  if (0 == uart_rxbuffer_get_count())
                  {
                      if (timeout_enable &&
                          tick_check_expire(timeout_cnt, UART_DATA_HANDLE_TIMEOUT))
                      {
                          // Êé•Êî∂Ë∂ÖÊó∂
                          // timeout_cnt = 0;
                          // timeout_cnt = tick_get();
                          timeout_enable = 0;                                     // ‰∏ç‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
                          uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE; // ÈáçÊñ∞ÂºÄÂßãÊé•Êî∂
              
                          // Ë∂ÖÊó∂‰πãÂêéÔºåÊâìÂç∞ÁºìÂÜ≤Âå∫ÂÜÖÁöÑÊï∞ÊçÆ
                          my_printf("=================================>\n");
                          my_printf("uart recv timeout\n");
                          for (i = 0; i < ARRAY_SIZE(cmd_buff); i++)
                          {
                              my_printf("%02x ", (u16)cmd_buff[i]);
                          }
                          my_printf("=================================^\n");
                      }
              
C51 COMPILER V9.60.7.0   UART_DATA_HANDLE                                                  02/26/2026 17:15:59 PAGE 4   

                      return; // ‰∏≤Âè£ÁºìÂÜ≤Âå∫ÁöÑÊï∞ÊçÆ‰∏∫Á©∫ÔºåÁõ¥Êé•ËøîÂõû
                  }
              
                  while (1) // ÊúâÊó∂ÂÄôËØ•ÂáΩÊï∞‰ºö100~200msÊâçË∞ÉÁî®‰∏ÄÊ¨°ÔºåËøôÈáå‰∏ÄÊ¨°ÊÄßÊääÁºìÂÜ≤Âå∫‰∏≠ÁöÑÊï∞ÊçÆËØ
             -ªÂá∫Êù•
                  {
                      if (uart_rxbuffer_get_count() == 0 || is_recv_complete) // ÈÄÄÂá∫Êù°‰ª∂
                      {
                          if (is_recv_complete)
                          {
                              is_recv_complete = 0;
                          }
              
                          break;
                      }
              
                      timeout_enable = 1;       // ‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
                      timeout_cnt = tick_get(); // Êõ¥Êñ∞Ë∂ÖÊó∂ËÆ°Êï∞ÁöÑÊó∂Âü∫
                      recv_byte = uart_rxbuffer_get_byte();
              
                      switch (uart_data_handle_status)
                      {
                      case UART_DATA_HANDLE_STATUS_IDLE:
                          if (UART_DATA_HANDLE_FORMAT_HEAD == recv_byte)
                          {
                              cmd_buff[0] = recv_byte;
                              cur_cmd_buff_len = 1;
                              uart_data_handle_status = UART_DATA_HANDLE_STATUS_FORMAT_HEAD;
                          }
                          else
                          {
                              // ‰∏çÊòØÊ†ºÂºèÂ§¥ÔºåÈáçÊñ∞ÂºÄÂßãÊé•Êî∂ÔºåÂÖ≥ÊéâË∂ÖÊó∂ËÆ°Êï∞
                              timeout_enable = 0;
                          }
                          break;
                          // ===============================================================
                      case UART_DATA_HANDLE_STATUS_FORMAT_HEAD:
                          cmd_buff[cur_cmd_buff_len++] = recv_byte;
                          dest_cmd_buff_len = recv_byte;                         // Â≠òÊîæË¶ÅÊé•Êî∂ÁöÑÊï∞ÊçÆÈïøÂ∫¶
                          uart_data_handle_status = UART_DATA_HANDLE_STATUS_LEN; // Ë°®Á§∫Êé•Êî∂Âà∞‰∫ÜÊï∞ÊçÆÂ∏ßÈïøÂ∫¶
                          // my_printf("len == %bu\n", dest_cmd_buff_len);
                          break;
                          // ===============================================================
                      case UART_DATA_HANDLE_STATUS_LEN:
                          cmd_buff[cur_cmd_buff_len++] = recv_byte;
                          if (cur_cmd_buff_len >= dest_cmd_buff_len) // Â¶ÇÊûúÊé•Êî∂ÂÆåÊâÄÊúâÁöÑÊï∞ÊçÆ
                          {
                              for (i = 0; i < dest_cmd_buff_len - 1; i++)
                              {
                                  check_sum += cmd_buff[i];
                              }
              
                              if (check_sum != cmd_buff[dest_cmd_buff_len - 1])
                              {
                                  // Ê†°È™åÂíåÈîôËØØ
                                  my_printf("=================================>\n");
                                  my_printf("check sum error\n");
                                  for (i = 0; i < ARRAY_SIZE(cmd_buff); i++)
                                  {
                                      my_printf("%02x ", (u16)cmd_buff[i]);
                                  }
                                  my_printf("=================================^\n");
C51 COMPILER V9.60.7.0   UART_DATA_HANDLE                                                  02/26/2026 17:15:59 PAGE 5   

              
                                  // timeout_cnt = 0;
                                  timeout_enable = 0;                                     // ‰∏ç‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
                                  uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE; // ÈáçÊñ∞Êé•Êî∂Êï∞ÊçÆ
                              }
                              else
                              {
                                  // Ê†°È™åÂíåÊ≠£Á°Æ
                                  my_printf("check sum ok\n");
                                  uart_data_handle_status = UART_DATA_HANDLE_STATUS_END;
                                  is_recv_complete = 1;
                              }
                          }
                          break;
                      // ===============================================================
                      default:
              
                          break;
                      }
                  }
              
                  if (UART_DATA_HANDLE_STATUS_END != uart_data_handle_status)
                  {
                      return; // Êú™Êé•Êî∂ÂÆåÊï∞ÊçÆÔºå‰∏çËøõÂÖ•‰∏ãÈù¢ÁöÑÂ§ÑÁêÜÊìç‰ΩúÔºåÂáΩÊï∞Áõ¥Êé•ËøîÂõû
                  }
              
                  // ÊâìÂç∞Êé•Êî∂Âà∞ÁöÑ‰∏ÄÂ∏ßÊï∞ÊçÆ
                  // for (i = 0; i < dest_cmd_buff_len; i++)
                  // {
                  //     my_printf("0x%02x ", (u16)cmd_buff[i]);
                  // }
                  // my_printf("\n");
              
                  // Â§ÑÁêÜ‰∏ÄÂ∏ßÊï∞ÊçÆÔºö
                  switch (cmd_buff[2])
                  {
                  }
              
                  // Â§ÑÁêÜÂÆåÊàêÂêéÔºåÈáçÊñ∞Êé•Êî∂Êï∞ÊçÆ
                  // timeout_cnt = 0;
                  timeout_enable = 0; // ‰∏ç‰ΩøËÉΩË∂ÖÊó∂ËÆ°Êï∞
                  uart_data_handle_status = UART_DATA_HANDLE_STATUS_IDLE;
              
              #endif
 279   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    360    ----
   CONSTANT SIZE    =    106    ----
   XDATA SIZE       =     16       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
