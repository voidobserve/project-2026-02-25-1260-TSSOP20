C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECV
OBJECT MODULE PLACED IN .\Release\Objects\rf_recv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_recv.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_recv.lst) OBJECT(.\Re
                    -lease\Objects\rf_recv.obj)

line level    source

   1          #include "rf_recv.h"
   2          
   3          // æ ‡å¿—ä½ï¼Œæ˜¯å¦å¤„äºrfå¯¹ç æ¨¡å¼
   4          // 0--æœªå¤„äº
   5          // 1--æ­£åœ¨å¯¹ç ï¼Œç­‰å¾…æŒ‰é”®é•¿æŒ‰
   6          // 2--å·²ç»å¯¹å®Œç ï¼Œç­‰å¾…æŒ‰é”®æ¾æ‰‹
   7          volatile u8 flag_is_in_rf_learning = 0;
   8          
   9          // rfå¯¹ç æœŸé—´ï¼Œç”¨äºä¸´æ—¶å­˜æ”¾é¥æ§å™¨åœ°å€çš„å˜é‡
  10          // åœ¨ rf_key_get_key_id() å‡½æ•°ä¸­å–å¾—ï¼Œå¦‚æœå¯¹ç æˆåŠŸï¼Œåˆ™ç›´æ¥åº”ç”¨è¯¥åœ°å€ï¼Œå†™å…¥flash
  11          volatile u32 tmp_rf_addr = 0xFFFFFFFF;
  12          volatile rf_remote_info_t rf_remote_info = {0};
  13          
  14          volatile bit flag_is_rf_enable = 0;      // æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½rfé¥æ§å™¨çš„åŠŸèƒ½
  15          volatile bit flag_is_recved_rf_data = 0; // æ˜¯å¦æ¥æ”¶åˆ°äº†rfä¿¡å·
  16          volatile u32 rf_data = 0;                // å­˜æ”¾æ¥æ”¶åˆ°çš„rfæ•°æ®
  17          
  18          // // å°†æŒ‰é”®é”®å€¼ä¸
  19          // static const u8 rf_key_map_table[][2] =
  20          // {
  21          
  22          // }
  23          
  24          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  25          enum RF_KEY_EVENT
  26          {
  27              RF_KEY_EVENT_NONE = 0,
  28              RF_KEY_EVENT_ID_1_CLICK,
  29              RF_KEY_EVENT_ID_1_LONG,
  30              RF_KEY_EVENT_ID_1_HOLD,
  31              RF_KEY_EVENT_ID_1_LOOSE,
  32          
  33              RF_KEY_EVENT_ID_2_CLICK,
  34              RF_KEY_EVENT_ID_2_LONG,
  35              RF_KEY_EVENT_ID_2_HOLD,
  36              RF_KEY_EVENT_ID_2_LOOSE,
  37          
  38              RF_KEY_EVENT_ID_3_CLICK,
  39              RF_KEY_EVENT_ID_3_LONG,
  40              RF_KEY_EVENT_ID_3_HOLD,
  41              RF_KEY_EVENT_ID_3_LOOSE,
  42          
  43              RF_KEY_EVENT_ID_4_CLICK,
  44              RF_KEY_EVENT_ID_4_LONG,
  45              RF_KEY_EVENT_ID_4_HOLD,
  46              RF_KEY_EVENT_ID_4_LOOSE,
  47          
  48              RF_KEY_EVENT_ID_5_CLICK,
  49              RF_KEY_EVENT_ID_5_LONG,
  50              RF_KEY_EVENT_ID_5_HOLD,
  51              RF_KEY_EVENT_ID_5_LOOSE,
  52          
  53              RF_KEY_EVENT_ID_6_CLICK,
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 2   

  54              RF_KEY_EVENT_ID_6_LONG,
  55              RF_KEY_EVENT_ID_6_HOLD,
  56              RF_KEY_EVENT_ID_6_LOOSE,
  57          
  58              RF_KEY_EVENT_ID_7_CLICK,
  59              RF_KEY_EVENT_ID_7_LONG,
  60              RF_KEY_EVENT_ID_7_HOLD,
  61              RF_KEY_EVENT_ID_7_LOOSE,
  62          
  63              RF_KEY_EVENT_ID_8_CLICK,
  64              RF_KEY_EVENT_ID_8_LONG,
  65              RF_KEY_EVENT_ID_8_HOLD,
  66              RF_KEY_EVENT_ID_8_LOOSE,
  67          
  68              RF_KEY_EVENT_ID_9_CLICK,
  69              RF_KEY_EVENT_ID_9_LONG,
  70              RF_KEY_EVENT_ID_9_HOLD,
  71              RF_KEY_EVENT_ID_9_LOOSE,
  72          
  73              RF_KEY_EVENT_ID_10_CLICK,
  74              RF_KEY_EVENT_ID_10_LONG,
  75              RF_KEY_EVENT_ID_10_HOLD,
  76              RF_KEY_EVENT_ID_10_LOOSE,
  77          
  78              RF_KEY_EVENT_ID_11_CLICK,
  79              RF_KEY_EVENT_ID_11_LONG,
  80              RF_KEY_EVENT_ID_11_HOLD,
  81              RF_KEY_EVENT_ID_11_LOOSE,
  82          
  83              RF_KEY_EVENT_ID_12_CLICK,
  84              RF_KEY_EVENT_ID_12_LONG,
  85              RF_KEY_EVENT_ID_12_HOLD,
  86              RF_KEY_EVENT_ID_12_LOOSE,
  87          
  88          #if USE_MY_TEST_433_REMOTE
              
                  // æµ‹è¯•æ—¶ä½¿ç”¨åˆ°çš„æŒ‰é”®äº‹ä»¶ï¼Œå®é™…ä¸ä½¿ç”¨
                  RF_KEY_EVENT_ID_TEST_1_CLICK,
                  RF_KEY_EVENT_ID_TEST_1_LONG,
                  RF_KEY_EVENT_ID_TEST_1_HOLD,
                  RF_KEY_EVENT_ID_TEST_1_LOOSE,
              
                  RF_KEY_EVENT_ID_TEST_2_CLICK,
                  RF_KEY_EVENT_ID_TEST_2_LONG,
                  RF_KEY_EVENT_ID_TEST_2_HOLD,
                  RF_KEY_EVENT_ID_TEST_2_LOOSE,
              
                  RF_KEY_EVENT_ID_TEST_3_CLICK,
                  RF_KEY_EVENT_ID_TEST_3_LONG,
                  RF_KEY_EVENT_ID_TEST_3_HOLD,
                  RF_KEY_EVENT_ID_TEST_3_LOOSE,
              
                  RF_KEY_EVENT_ID_TEST_4_CLICK,
                  RF_KEY_EVENT_ID_TEST_4_LONG,
                  RF_KEY_EVENT_ID_TEST_4_HOLD,
                  RF_KEY_EVENT_ID_TEST_4_LOOSE,
              
              #endif // #if USE_MY_TEST_433_REMOTE
 112          };
 113          
 114          #define RF_KEY_EFFECT_EVENT_NUMS (4) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•° (å•å‡»ã€é•¿æŒ‰ã€æ
             -Œç»­ã€æ¾å¼€)
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 3   

 115          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
 116          // static const u8 rf_key_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
 117          //     // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰ç
             -š„æŒ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
 118          //     {RF_KEY_ID_1, RF_KEY_EVENT_ID_1_CLICK, RF_KEY_EVENT_ID_1_LONG, RF_KEY_EVENT_ID_1_HOLD, RF_KEY_EVENT
             -_ID_1_LOOSE},      //
 119          //     {RF_KEY_ID_2, RF_KEY_EVENT_ID_2_CLICK, RF_KEY_EVENT_ID_2_LONG, RF_KEY_EVENT_ID_2_HOLD, RF_KEY_EVENT
             -_ID_2_LOOSE},      //
 120          //     {RF_KEY_ID_3, RF_KEY_EVENT_ID_3_CLICK, RF_KEY_EVENT_ID_3_LONG, RF_KEY_EVENT_ID_3_HOLD, RF_KEY_EVENT
             -_ID_3_LOOSE},      //
 121          //     {RF_KEY_ID_4, RF_KEY_EVENT_ID_4_CLICK, RF_KEY_EVENT_ID_4_LONG, RF_KEY_EVENT_ID_4_HOLD, RF_KEY_EVENT
             -_ID_4_LOOSE},      //
 122          //     {RF_KEY_ID_5, RF_KEY_EVENT_ID_5_CLICK, RF_KEY_EVENT_ID_5_LONG, RF_KEY_EVENT_ID_5_HOLD, RF_KEY_EVENT
             -_ID_5_LOOSE},      //
 123          //     {RF_KEY_ID_6, RF_KEY_EVENT_ID_6_CLICK, RF_KEY_EVENT_ID_6_LONG, RF_KEY_EVENT_ID_6_HOLD, RF_KEY_EVENT
             -_ID_6_LOOSE},      //
 124          //     {RF_KEY_ID_7, RF_KEY_EVENT_ID_7_CLICK, RF_KEY_EVENT_ID_7_LONG, RF_KEY_EVENT_ID_7_HOLD, RF_KEY_EVENT
             -_ID_7_LOOSE},      //
 125          //     {RF_KEY_ID_8, RF_KEY_EVENT_ID_8_CLICK, RF_KEY_EVENT_ID_8_LONG, RF_KEY_EVENT_ID_8_HOLD, RF_KEY_EVENT
             -_ID_8_LOOSE},      //
 126          //     {RF_KEY_ID_9, RF_KEY_EVENT_ID_9_CLICK, RF_KEY_EVENT_ID_9_LONG, RF_KEY_EVENT_ID_9_HOLD, RF_KEY_EVENT
             -_ID_9_LOOSE},      //
 127          //     {RF_KEY_ID_10, RF_KEY_EVENT_ID_10_CLICK, RF_KEY_EVENT_ID_10_LONG, RF_KEY_EVENT_ID_10_HOLD, RF_KEY_E
             -VENT_ID_10_LOOSE}, //
 128          //     {RF_KEY_ID_11, RF_KEY_EVENT_ID_11_CLICK, RF_KEY_EVENT_ID_11_LONG, RF_KEY_EVENT_ID_11_HOLD, RF_KEY_E
             -VENT_ID_11_LOOSE}, //
 129          //     {RF_KEY_ID_12, RF_KEY_EVENT_ID_12_CLICK, RF_KEY_EVENT_ID_12_LONG, RF_KEY_EVENT_ID_12_HOLD, RF_KEY_E
             -VENT_ID_12_LOOSE}, //
 130          
 131          // #if USE_MY_TEST_433_REMOTE
 132          
 133          //     {RF_KEY_ID_TEST_1, RF_KEY_EVENT_ID_TEST_1_CLICK, RF_KEY_EVENT_ID_TEST_1_LONG, RF_KEY_EVENT_ID_TEST_
             -1_HOLD, RF_KEY_EVENT_ID_TEST_1_LOOSE}, //
 134          //     {RF_KEY_ID_TEST_2, RF_KEY_EVENT_ID_TEST_2_CLICK, RF_KEY_EVENT_ID_TEST_2_LONG, RF_KEY_EVENT_ID_TEST_
             -2_HOLD, RF_KEY_EVENT_ID_TEST_2_LOOSE}, //
 135          //     {RF_KEY_ID_TEST_3, RF_KEY_EVENT_ID_TEST_3_CLICK, RF_KEY_EVENT_ID_TEST_3_LONG, RF_KEY_EVENT_ID_TEST_
             -3_HOLD, RF_KEY_EVENT_ID_TEST_3_LOOSE}, //
 136          //     {RF_KEY_ID_TEST_4, RF_KEY_EVENT_ID_TEST_4_CLICK, RF_KEY_EVENT_ID_TEST_4_LONG, RF_KEY_EVENT_ID_TEST_
             -4_HOLD, RF_KEY_EVENT_ID_TEST_4_LOOSE}, //
 137          
 138          // #endif // #if USE_MY_TEST_433_REMOTE
 139          // };
 140          
 141          // æ§åˆ¶ä¸€è·¯PWMé¥æ§å™¨å¯¹åº”çš„è¡¨æ ¼
 142          static const u8 rf_key_1_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
 143              {RF_KEY_ID_9, RF_KEY_EVENT_ID_9_CLICK, RF_KEY_EVENT_ID_9_LONG, RF_KEY_EVENT_ID_9_HOLD, RF_KEY_EVENT_ID
             -_9_LOOSE},      //
 144              {RF_KEY_ID_10, RF_KEY_EVENT_ID_10_CLICK, RF_KEY_EVENT_ID_10_LONG, RF_KEY_EVENT_ID_10_HOLD, RF_KEY_EVEN
             -T_ID_10_LOOSE}, //
 145              {RF_KEY_ID_11, RF_KEY_EVENT_ID_11_CLICK, RF_KEY_EVENT_ID_11_LONG, RF_KEY_EVENT_ID_11_HOLD, RF_KEY_EVEN
             -T_ID_11_LOOSE}, //
 146              {RF_KEY_ID_12, RF_KEY_EVENT_ID_12_CLICK, RF_KEY_EVENT_ID_12_LONG, RF_KEY_EVENT_ID_12_HOLD, RF_KEY_EVEN
             -T_ID_12_LOOSE}, //
 147          };
 148          
 149          // æ§åˆ¶ä¸¤è·¯PWMé¥æ§å™¨å¯¹åº”çš„è¡¨æ ¼
 150          static const u8 rf_key_1_2_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
 151              {RF_KEY_ID_1, RF_KEY_EVENT_ID_1_CLICK, RF_KEY_EVENT_ID_1_LONG, RF_KEY_EVENT_ID_1_HOLD, RF_KEY_EVENT_ID
             -_1_LOOSE}, //
 152              {RF_KEY_ID_2, RF_KEY_EVENT_ID_2_CLICK, RF_KEY_EVENT_ID_2_LONG, RF_KEY_EVENT_ID_2_HOLD, RF_KEY_EVENT_ID
             -_2_LOOSE}, //
 153              {RF_KEY_ID_3, RF_KEY_EVENT_ID_3_CLICK, RF_KEY_EVENT_ID_3_LONG, RF_KEY_EVENT_ID_3_HOLD, RF_KEY_EVENT_ID
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 4   

             -_3_LOOSE}, //
 154              {RF_KEY_ID_4, RF_KEY_EVENT_ID_4_CLICK, RF_KEY_EVENT_ID_4_LONG, RF_KEY_EVENT_ID_4_HOLD, RF_KEY_EVENT_ID
             -_4_LOOSE}, //
 155              {RF_KEY_ID_5, RF_KEY_EVENT_ID_5_CLICK, RF_KEY_EVENT_ID_5_LONG, RF_KEY_EVENT_ID_5_HOLD, RF_KEY_EVENT_ID
             -_5_LOOSE}, //
 156              {RF_KEY_ID_6, RF_KEY_EVENT_ID_6_CLICK, RF_KEY_EVENT_ID_6_LONG, RF_KEY_EVENT_ID_6_HOLD, RF_KEY_EVENT_ID
             -_6_LOOSE}, //
 157              {RF_KEY_ID_7, RF_KEY_EVENT_ID_7_CLICK, RF_KEY_EVENT_ID_7_LONG, RF_KEY_EVENT_ID_7_HOLD, RF_KEY_EVENT_ID
             -_7_LOOSE}, //
 158              {RF_KEY_ID_8, RF_KEY_EVENT_ID_8_CLICK, RF_KEY_EVENT_ID_8_LONG, RF_KEY_EVENT_ID_8_HOLD, RF_KEY_EVENT_ID
             -_8_LOOSE}, //
 159          };
 160          
 161          extern u8 rf_key_get_key_id(void);
 162          volatile struct key_driver_para rf_key_para = {
 163              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
 164              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 165              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
 166              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
 167              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
 168              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 169              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 170              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 171              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
 172              // // .click_cnt = 0,
 173              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 174              // // .notify_value = 0,
 175              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
 176              // .get_value = ad_key_get_key_id,
 177          
 178              // .latest_key_val = AD_KEY_ID_NONE,
 179              // .latest_key_event = KEY_EVENT_NONE,
 180          
 181              RF_KEY_SCAN_CIRCLE_TIMES, // .scan_times æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 182              0,                        // .cur_scan_times æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®šæ—¶å™¨ä¸­æ–­å†
             -…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
 183              // NO_KEY,
 184              0, // .last_key
 185          
 186              0,                   // .filter_value
 187              0,                   // .filter_cnt
 188              RF_KEY_FILTER_TIMES, // .filter_time æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³ï¼ˆrfæŒ‰é”®ä¸æ¶ˆæŠ–ï¼‰
 189          
 190              RF_LONG_PRESS_TIME_THRESHOLD_MS / RF_KEY_SCAN_CIRCLE_TIMES,                                     // .lo
             -ng_time
 191              (RF_LONG_PRESS_TIME_THRESHOLD_MS + RF_HOLD_PRESS_TIME_THRESHOLD_MS) / RF_KEY_SCAN_CIRCLE_TIMES, // .ho
             -ld_time
 192              0,                                                                                              // .pr
             -ess_cnt
 193          
 194              0,                              // .click_cnt
 195              0,                              // .click_delay_cnt
 196              200 / RF_KEY_SCAN_CIRCLE_TIMES, // .click_delay_time
 197              // NO_KEY,
 198              0,                 // .notify_value
 199              KEY_TYPE_RF,       // .key_type
 200              rf_key_get_key_id, // .get_value
 201          
 202              NO_KEY,         // .latest_key_val
 203              KEY_EVENT_NONE, // .latest_key_event
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 5   

 204          }; // volatile struct key_driver_para rf_key_para
 205          
 206          /**
 207           * @brief è·å– rf é¥æ§å™¨æŒ‰é”®é”®å€¼ï¼Œä¾› key_driver è°ƒç”¨
 208           *          è¿™é‡Œä¸èƒ½åŒºåˆ†é¥æ§å™¨ç±»å‹ï¼Œåªèƒ½è·å–é¥æ§å™¨æŒ‰é”®
 209           *
 210           * @return u8
 211           */
 212          static u8 rf_key_get_key_id(void)
 213          {
 214   1          if (flag_is_recved_rf_data)
 215   1          {
 216   2              flag_is_recved_rf_data = 0;
 217   2              if (rf_data)
 218   2              {
 219   3                  // u8 ret = (u8)rf_data;
 220   3                  // u8 ret = ((u8)rf_data) & 0x0F; // è·å–ä½4ä½ä½œä¸ºé”®å€¼
 221   3                  u8 ret = ((u8)rf_data) & 0xFF; // è·å–ä½8ä½ä½œä¸ºé”®å€¼
 222   3      
 223   3                  // printf("rf_data 0x %lx\n", rf_data);
 224   3      
 225   3                  if (flag_is_in_rf_learning)
 226   3                  {
 227   4                      // å¦‚æœåœ¨rfå¯¹ç æœŸé—´ï¼Œç›´æ¥è·å–åœ°å€
 228   4                      // tmp_rf_addr = ((u32)rf_data >> 8);
 229   4      
 230   4                      if (RF_KEY_ID_12 == (ret & 0x0F))
 231   4                      {
 232   5                          tmp_rf_addr = ((u32)rf_data) >> 4; // æ•°æ®é«˜20ä½æ˜¯åœ°å€ï¼Œä½4ä½æ˜¯é”®å€¼
 233   5                          ret &= 0x0F;
 234   5                      }
 235   4                      else if (RF_KEY_ID_1 == ret)
 236   4                      {
 237   5                          // å¦‚æœæ˜¯æ§åˆ¶ä¸¤è·¯PWMçš„é¥æ§å™¨åœ¨å¯¹ç 
 238   5                          tmp_rf_addr = ((u32)rf_data) >> 8; // æ•°æ®é«˜16ä½æ˜¯åœ°å€ï¼Œä½8ä½æ˜¯é”®å€¼
 239   5                      }
 240   4      
 241   4                      // printf("tmp_rf_addr 0x %lx\n", tmp_rf_addr);
 242   4                  }
 243   3                  else
 244   3                  {
 245   4                      // å¦‚æœä¸åœ¨rfå¯¹ç æœŸé—´ï¼Œå¹¶ä¸”é¥æ§å™¨çš„åœ°å€ä¸ä¸€è‡´
 246   4                      // if ((rf_data >> 8) != rf_remote_info.rf_addr)
 247   4                      // if ((rf_data >> 4) != rf_remote_info.rf_addr) // æ•°æ®é«˜20ä½æ˜¯åœ°å€ï¼Œä½4ä½æ˜¯é”
             -®å€¼
 248   4      
 249   4                      if (rf_remote_info.is_addr_valid == 0xC5)
 250   4                      {
 251   5                          // å¦‚æœä¹‹å‰å­˜æ”¾äº†æœ‰æ•ˆçš„é¥æ§å™¨çš„åœ°å€
 252   5                          // åˆ¤æ–­é¥æ§å™¨ç±»å‹ï¼š
 253   5                          if (1 == rf_remote_info.rf_remote_type &&
 254   5                              (rf_data >> 4) == rf_remote_info.rf_addr)
 255   5                          {
 256   6                              // å¦‚æœæ˜¯æ§åˆ¶ä¸€è·¯PWMçš„é¥æ§å™¨ï¼Œæ¥æ”¶åˆ°çš„æ•°æ®ä½4ä½æ˜¯é”®å€¼
 257   6                              ret &= 0x0F;
 258   6                          }
 259   5                          else if (2 == rf_remote_info.rf_remote_type &&
 260   5                                   (rf_data >> 8) == rf_remote_info.rf_addr)
 261   5                          {
 262   6                              // å¦‚æœæ˜¯æ§åˆ¶ä¸¤è·¯PWMçš„é¥æ§å™¨ï¼Œæ¥æ”¶åˆ°çš„æ•°æ®ä½8ä½æ˜¯é”®å€¼
 263   6                              // ret &= 0xFF; // å¯ä»¥ä¸å†™è¿™ä¸€å¥
 264   6                          }
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 6   

 265   5                          else
 266   5                          {
 267   6                              // å¦‚æœé¥æ§å™¨çš„åœ°å€ä¸ä¸€æ ·
 268   6                              ret = NO_KEY;
 269   6                          }
 270   5                      }
 271   4                      else
 272   4                      {
 273   5                          // å¦‚æœä¹‹å‰æ²¡æœ‰å­˜æ”¾æœ‰æ•ˆçš„é¥æ§å™¨çš„åœ°å€
 274   5                          ret = NO_KEY;
 275   5                      }
 276   4                  }
 277   3      
 278   3                  // printf("key id %bu\n", ret);
 279   3                  rf_data = 0;    // æ¥æ”¶å®Œæˆåï¼Œæ¸…é™¤æ¥æ”¶åˆ°çš„æ•°æ®
 280   3                  return (u8)ret; // ç›´æ¥è·å–é”®å€¼
 281   3              }
 282   2              else
 283   2              {
 284   3                  return NO_KEY;
 285   3              }
 286   2          }
 287   1          else
 288   1          {
 289   2              return NO_KEY;
 290   2          }
 291   1      }
 292          
 293          /**
 294           * @brief __rf_key_get_eventçš„å­å‡½æ•°ï¼Œå°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè
             -§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 295           *
 296           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 297           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 298           * @param table_index åœ¨å“ªä¸ªè¡¨æ ¼ä¸­è¿›è¡ŒæŸ¥è¡¨ï¼Œ
 299           *                      1--åœ¨æ§åˆ¶ä¸€è·¯PWMé¥æ§å™¨å¯¹åº”çš„è¡¨æ ¼
 300           *                      2--æ§åˆ¶ä¸¤è·¯PWMé¥æ§å™¨å¯¹åº”çš„è¡¨æ ¼
 301           * @return u8
 302           */
 303          static u8 __sub_fun_rf_key_get_event(const u8 key_val, const u8 key_event, const u8 table_index)
 304          {
 305   1          u8 ret_key_event = RF_KEY_EVENT_NONE;
 306   1          u8 i = 0;
 307   1          if (1 == table_index)
 308   1          {
 309   2              for (i = 0; i < ARRAY_SIZE(rf_key_1_event_table); i++)
 310   2              {
 311   3                  // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•
             -ˆï¼Œéœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 312   3                  if (key_val == rf_key_1_event_table[i][0])
 313   3                  {
 314   4                      ret_key_event = rf_key_1_event_table[i][key_event];
 315   4                      break;
 316   4                  }
 317   3              }
 318   2          }
 319   1          else if (2 == table_index)
 320   1          {
 321   2              for (i = 0; i < ARRAY_SIZE(rf_key_1_2_event_table); i++)
 322   2              {
 323   3                  // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•
             -ˆï¼Œéœ€è¦æ‰‹åŠ¨ä¿®æ”¹
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 7   

 324   3                  if (key_val == rf_key_1_2_event_table[i][0])
 325   3                  {
 326   4                      ret_key_event = rf_key_1_2_event_table[i][key_event];
 327   4                      break;
 328   4                  }
 329   3              }
 330   2          }
 331   1          else
 332   1          {
 333   2              // ä¼ å‚æœ‰è¯¯
 334   2          }
 335   1      
 336   1          return ret_key_event;
 337   1      }
 338          
 339          /**
 340           * @brief å°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 341           *          å‡½æ•°å†…éƒ¨ä¼šåšé¥æ§å™¨ç±»å‹åŒºåˆ†
 342           *
 343           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 344           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 345           * @return u8 åœ¨ rf_key_event_table ä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› RF_KEY_EVEN
             -T_NONE
 346           */
 347          static u8 __rf_key_get_event(const u8 key_val, const u8 key_event)
 348          {
 349   1          volatile u8 ret_key_event = RF_KEY_EVENT_NONE;
 350   1          u8 i = 0;
 351   1      
 352   1          if (flag_is_in_rf_learning)
 353   1          {
 354   2              // å¦‚æœåœ¨å¯¹ç é˜¶æ®µ
 355   2              /*
 356   2                  å…ˆåˆ¤æ–­ä¹‹å‰æ˜¯å¦å­˜æ”¾äº†æœ‰æ•ˆçš„é¥æ§å™¨
 357   2                      å¦‚æœæœ‰ï¼Œåˆ¤æ–­ç°åœ¨è¯»åˆ°çš„é¥æ§å™¨æŒ‰é”®æ˜¯å¦ä¸å­˜æ”¾çš„é¥æ§å™¨ä¿¡æ¯ä¸€è‡´
 358   2                          å¦‚æœä¸€è‡´ï¼Œè¿›è¡ŒæŸ¥è¡¨
 359   2                          å¦‚æœä¸ä¸€è‡´ï¼Œåˆ¤æ–­é”®å€¼æ˜¯ä¸æ˜¯å¯¹ç æŒ‰é”®
 360   2                              å¦‚æœæ˜¯1+2åŒè·¯PWMé¥æ§å™¨çš„å¯¹ç æŒ‰é”®
 361   2                              å¦‚æœæ˜¯å•è·¯PWMé¥æ§å™¨çš„å¯¹ç æŒ‰é”®
 362   2                      å¦‚æœæ²¡æœ‰ï¼Œåˆ¤æ–­é”®å€¼æ˜¯ä¸æ˜¯å¯¹ç æŒ‰é”®
 363   2                          å¦‚æœæ˜¯1+2åŒè·¯PWMé¥æ§å™¨çš„å¯¹ç æŒ‰é”®
 364   2                          å¦‚æœæ˜¯å•è·¯PWMé¥æ§å™¨çš„å¯¹ç æŒ‰é”®
 365   2              */
 366   2              if (tmp_rf_addr == rf_remote_info.rf_addr && rf_remote_info.is_addr_valid == 0xC5)
 367   2              {
 368   3                  // ä¹‹å‰å­˜æ”¾äº†æœ‰æ•ˆçš„é¥æ§å™¨ï¼Œå¹¶ä¸”ç°åœ¨è¯»åˆ°çš„é¥æ§å™¨çš„åœ°å€ä¸€æ ·
 369   3                  if (1 == rf_remote_info.rf_remote_type)
 370   3                  {
 371   4                      // å•è·¯PWMé¥æ§å™¨
 372   4                      ret_key_event = __sub_fun_rf_key_get_event(key_val, key_event, 1);
 373   4                  }
 374   3                  else if (2 == rf_remote_info.rf_remote_type)
 375   3                  {
 376   4                      // 1+2ä¸¤è·¯PWMé¥æ§å™¨
 377   4                      ret_key_event = __sub_fun_rf_key_get_event(key_val, key_event, 2);
 378   4                  }
 379   3              }
 380   2              else
 381   2              {
 382   3                  // ç°åœ¨è¯»åˆ°çš„é¥æ§å™¨æŒ‰é”®æ˜¯å¦ä¸å­˜æ”¾çš„é¥æ§å™¨ä¿¡æ¯ä¸ä¸€è‡´ï¼Œæˆ–è€…ä¹‹å‰æ²¡æ
             -œ‰å­˜æ”¾æœ‰æ•ˆçš„é¥æ§å™¨
 383   3                  // å¼€å§‹åˆ¤æ–­æ˜¯ä¸æ˜¯å¯¹ç æŒ‰é”®
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 8   

 384   3                  if (RF_KEY_ID_1 == key_val)
 385   3                  {
 386   4                      // å¦‚æœæ˜¯1+2åŒè·¯PWMé¥æ§å™¨çš„å¯¹ç æŒ‰é”®
 387   4                      ret_key_event = __sub_fun_rf_key_get_event(key_val, key_event, 2);
 388   4      
 389   4                      // printf("rf type 1+2\n");
 390   4                  }
 391   3                  else if (RF_KEY_ID_12 == key_val)
 392   3                  {
 393   4                      // å¦‚æœæ˜¯å•è·¯PWMé¥æ§å™¨çš„å¯¹ç æŒ‰é”®
 394   4                      ret_key_event = __sub_fun_rf_key_get_event(key_val, key_event, 1);
 395   4                      // printf("rf type 1\n");
 396   4                  }
 397   3                  else
 398   3                  {
 399   4                      // ret_key_event = RF_KEY_EVENT_NONE;
 400   4                  }
 401   3              }
 402   2          } // if (flag_is_in_rf_learning) // å¦‚æœåœ¨å¯¹ç é˜¶æ®µ
 403   1          else
 404   1          {
 405   2              // å¦‚æœä¸åœ¨å¯¹ç é˜¶æ®µ
 406   2              if (tmp_rf_addr == rf_remote_info.rf_addr && rf_remote_info.is_addr_valid == 0xC5)
 407   2              {
 408   3                  // ä¹‹å‰å­˜æ”¾äº†æœ‰æ•ˆçš„é¥æ§å™¨ï¼Œå¹¶ä¸”ç°åœ¨è¯»åˆ°çš„é¥æ§å™¨çš„åœ°å€ä¸€æ ·
 409   3                  if (1 == rf_remote_info.rf_remote_type)
 410   3                  {
 411   4                      // å•è·¯PWMé¥æ§å™¨
 412   4                      ret_key_event = __sub_fun_rf_key_get_event(key_val, key_event, 1);
 413   4                  }
 414   3                  else if (2 == rf_remote_info.rf_remote_type)
 415   3                  {
 416   4                      // 1+2ä¸¤è·¯PWMé¥æ§å™¨
 417   4                      ret_key_event = __sub_fun_rf_key_get_event(key_val, key_event, 2);
 418   4                  }
 419   3              }
 420   2              else
 421   2              {
 422   3                  // ret_key_event = RF_KEY_EVENT_NONE;
 423   3              }
 424   2          }
 425   1      
 426   1          return ret_key_event;
 427   1      }
 428          
 429          //  å‡½æ•°å†…éƒ¨ä¼šåšé¥æ§å™¨ç±»å‹åŒºåˆ†
 430          void rf_key_handle(void)
 431          {
 432   1          u8 rf_key_event = RF_KEY_EVENT_NONE;
 433   1      
 434   1          // å¦‚æœæ˜¯æ— æ•ˆçš„æŒ‰é”®ä¿¡æ¯ï¼Œå‡½æ•°ç›´æ¥è¿”å›
 435   1          if (rf_key_para.latest_key_val == NO_KEY)
 436   1          {
 437   2              return;
 438   2          }
 439   1      
 440   1          rf_key_event = __rf_key_get_event(rf_key_para.latest_key_val, rf_key_para.latest_key_event);
 441   1          rf_key_para.latest_key_val = NO_KEY;
 442   1          rf_key_para.latest_key_event = KEY_EVENT_NONE;
 443   1      
 444   1          { // ç”¨äºè¿›è¡Œå¯¹ç çš„ä»£ç å—
 445   2              static u8 last_key_event = KEY_EVENT_NONE;
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 9   

 446   2      
 447   2              if (1 == flag_is_in_rf_learning) // å¤„äºrfå¯¹ç æœŸé—´ï¼Œæ‰è¿›å…¥
 448   2              {
 449   3                  // å¦‚æœä¸Šä¸€æ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ã€é”®å€¼å’Œäº‹ä»¶ã€‘ ä¸æœ€æ–°æ£€æµ‹åˆ°çš„ã€é”®å€¼å’Œäº‹
             -ä»¶ã€‘ç›¸ç­‰ï¼Œè¯´æ˜æ˜¯åŒä¸€ä¸ªæŒ‰é”®é•¿æŒ‰
 450   3                  if (last_key_event == rf_key_event)
 451   3                  {
 452   4                      // åªæœ‰æŒ‰ä¸‹ å¼€æœº/å…³æœº æŒ‰é”®ï¼Œæ‰è¿›è¡Œå¯¹ç 
 453   4                      if (RF_KEY_EVENT_ID_1_HOLD == rf_key_event ||
 454   4                          RF_KEY_EVENT_ID_12_HOLD == rf_key_event)
 455   4                      {
 456   5                          // å¦‚æœä¸€å®šè¦é•¿æŒ‰ä¸€æ®µæ—¶é—´åœ¨å¯¹ç ï¼Œå¯ä»¥åŠ ä¸Šä¸‹é¢çš„è¯­å¥ï¼š
 457   5                          // static u16 hold_cnt = 0; // é•¿æŒ‰è®¡æ•°å€¼ï¼Œå¦‚æœé•¿æŒ‰äº†ä¸€æ®µæ—¶é—´ï¼Œè¿›è¡Œå
             -¯¹ç 
 458   5                          // hold_cnt++;
 459   5      
 460   5                          // if (hold_cnt >= 1)
 461   5                          {
 462   6                              // hold_cnt = 0;
 463   6                              // å­˜æ”¾å¯¹ç çš„åœ°å€
 464   6                              rf_remote_info.is_addr_valid = 0xC5; // è¡¨ç¤ºè®°å½•äº†ä¸€ä¸ªæœ‰æ•ˆçš„æŒ‰é”®åœ°å€
 465   6                              rf_remote_info.rf_addr = tmp_rf_addr;
 466   6                              // è®°å½•é¥æ§å™¨çš„ç±»å‹ï¼š
 467   6                              if (RF_KEY_EVENT_ID_1_HOLD == rf_key_event)
 468   6                              {
 469   7                                  // 2--1+2ä¸¤è·¯PWMé¥æ§å™¨
 470   7                                  rf_remote_info.rf_remote_type = 2;
 471   7                              }
 472   6                              else // RF_KEY_EVENT_ID_12_HOLD == rf_key_event
 473   6                              {
 474   7                                  // 1--å•è·¯PWMé¥æ§å™¨
 475   7                                  rf_remote_info.rf_remote_type = 1;
 476   7                              }
 477   6      
 478   6                              flash_erase_sector(FLASH_START_ADDR);
 479   6                              flash_program(FLASH_START_ADDR, (u8 *)&rf_remote_info, sizeof(rf_remote_info));
 480   6      
 481   6      #if USE_MY_DEBUG
                                      // printf("rf learn\n");
                                      // printf("rf_remote_type %bu\n", rf_remote_info.rf_remote_type);
                                      // printf("learn addr: 0x %lx\n", rf_remote_info.rf_addr);
              #endif
 486   6                              flag_is_in_rf_learning = 2; // å¯¹ç å®Œæˆåï¼Œç­‰å¾…æŒ‰é”®æ¾æ‰‹
 487   6                          }
 488   5                      }
 489   4                  }
 490   3                  else
 491   3                  {
 492   4                      last_key_event = rf_key_event;
 493   4                  }
 494   3              }
 495   2              else if (2 == flag_is_in_rf_learning) // ç­‰å¾…å¯¹ç æŒ‰é”®æ¾æ‰‹
 496   2              {
 497   3                  if (RF_KEY_EVENT_ID_1_LOOSE == rf_key_event || /* å¦‚æœæ£€æµ‹åˆ°æ§åˆ¶ä¸¤è·¯PWMçš„é¥æ§å™¨çš
             -„å¼€å…³æŒ‰é”®æ¾æ‰‹ */
 498   3                      RF_KEY_EVENT_ID_12_LOOSE == rf_key_event)  /* å¦‚æœæ£€æµ‹åˆ°æ§åˆ¶ä¸€è·¯PWMçš„é¥æ§å™¨çš
             -„å¼€å…³æŒ‰é”®æ¾æ‰‹ */
 499   3                  {
 500   4                      flag_is_in_rf_learning = 0; // é€€å‡ºå¯¹ç /å­¦ä¹ 
 501   4                      return;
 502   4                  }
 503   3              }
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 10  

 504   2      
 505   2          } // ç”¨äºè¿›è¡Œå¯¹ç çš„ä»£ç å—
 506   1      
 507   1          // printf("rf event %bu\n", rf_key_event);
 508   1      
 509   1          // å¦‚æœæŒ‰é”®åœ°å€æ— æ•ˆï¼Œæœªè¿›è¡Œå¯¹ç ï¼Œå‡½æ•°ç›´æ¥è¿”å›ï¼Œä¸è¿›è¡Œé”®å€¼å¤„ç†
 510   1          // æ­£åœ¨è¿›è¡Œå¯¹ç ï¼Œä¸è¿›è¡Œé”®å€¼å¤„ç†
 511   1          // if (0xC5 != rf_remote_info.is_addr_valid || flag_is_in_rf_learning)
 512   1          if (0xC5 != rf_remote_info.is_addr_valid) /* å¦‚æœä¹‹å‰æœªè¿›è¡Œå¯¹ç ï¼Œä¸è¿›è¡Œé”®å€¼å¤„ç† */
 513   1          {
 514   2              return;
 515   2          }
 516   1      
 517   1          // æ­£åœ¨å­¦ä¹ ï¼Œä½†æ˜¯æ¥æ”¶åˆ°çš„æŒ‰é”®åœ°å€ä¸è®°å½•çš„åœ°å€ä¸€æ ·:
 518   1          if (flag_is_in_rf_learning && rf_remote_info.rf_addr == tmp_rf_addr)
 519   1          {
 520   2              // å¦‚æœè¿˜åœ¨å¯¹ç /å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œé€€å‡ºå¯¹ç /å­¦ä¹ 
 521   2              flag_is_in_rf_learning = 0;
 522   2          }
 523   1          // else
 524   1          // {
 525   1          //     // å¦‚æœæŒ‰é”®æ— æ•ˆ(ä¸å¤„äºå¯¹ç æœŸé—´ï¼Œæˆ–æ˜¯æŒ‰é”®çš„åœ°å€ä¸è®°å½•çš„åœ°å€ä¸ä¸€æ ·)
 526   1          //     return;
 527   1          // }
 528   1      
 529   1          switch (rf_key_event)
 530   1          {
 531   2          case RF_KEY_EVENT_ID_1_CLICK: // ON/OFF
 532   2          case RF_KEY_EVENT_ID_1_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯ ON/OFF
 533   2      
 534   2              // printf("key 1 click\n");
 535   2      
 536   2              // åªè¦æœ‰ä¸€è·¯å¼€å¯ï¼Œä¾¿è®¤ä¸ºç¯å…‰å·²ç»æ‰“å¼€ï¼š
 537   2              if (get_pwm_channel_0_status() || get_pwm_channel_1_status())
 538   2              {
 539   3                  expect_adjust_pwm_channel_0_duty = 0;
 540   3                  expect_adjust_pwm_channel_1_duty = 0;
 541   3                  // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(0);
 542   3                  // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(0);
 543   3                  // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°
             -å€¼
 544   3                  // cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°
             -å€¼
 545   3                  // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 546   3                  // set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 547   3      
 548   3                  // pwm_channel_0_disable();
 549   3                  // pwm_channel_1_disable();
 550   3      
 551   3                  // printf("all pwm channels are disable\n");
 552   3              }
 553   2              else
 554   2              {
 555   3                  expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY;
 556   3                  expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY;
 557   3                  // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 558   3                  // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 559   3      
 560   3                  // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°
             -å€¼
 561   3                  // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 562   3      
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 11  

 563   3                  // cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°
             -å€¼
 564   3                  // set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 565   3      
 566   3                  // pwm_channel_0_enable();
 567   3                  // pwm_channel_1_enable();
 568   3      
 569   3                  // printf("all pwm channels are enable\n");
 570   3              }
 571   2      
 572   2              break;
 573   2      
 574   2          case RF_KEY_EVENT_ID_2_CLICK: // 1+2æŒ‰é”®ï¼Œäº®åº¦è®¾ç½®ä¸º100%
 575   2          case RF_KEY_EVENT_ID_2_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯ å°† 1+2 äº®åº¦è®¾ç½®ä¸º100%
 576   2      
 577   2              // printf("key 2 click\n");
 578   2      
 579   2              expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY;
 580   2              expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY;
 581   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_100_PERCENT);
 582   2              // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_100_PERCENT);
 583   2      
 584   2              // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 585   2              // cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 586   2      
 587   2              // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 588   2              // set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 589   2      
 590   2              break;
 591   2      
 592   2          case RF_KEY_EVENT_ID_3_CLICK: // å¢åŠ  pwm_channel_0 duty
 593   2      
 594   2              expect_adjust_pwm_channel_0_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 595   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 596   2              {
 597   3                  // é˜²æ­¢æº¢å‡º
 598   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 599   3              }
 600   2      
 601   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 602   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 603   2      
 604   2              break;
 605   2      
 606   2          case RF_KEY_EVENT_ID_3_HOLD: // å¢åŠ  pwm_channel_0 duty
 607   2      
 608   2              expect_adjust_pwm_channel_0_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
             -LD_PRESS_TIME_THRESHOLD_MS);
 609   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 610   2              {
 611   3                  // é˜²æ­¢æº¢å‡º
 612   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 613   3              }
 614   2      
 615   2              break;
 616   2      
 617   2          case RF_KEY_EVENT_ID_4_CLICK: // å¢åŠ  pwm_channel_1 duty
 618   2      
 619   2              // printf("key 4 click\n");
 620   2              expect_adjust_pwm_channel_1_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 621   2              if (expect_adjust_pwm_channel_1_duty > PWM_DUTY_100_PERCENT)
 622   2              {
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 12  

 623   3                  // é˜²æ­¢æº¢å‡º
 624   3                  expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 625   3              }
 626   2      
 627   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 628   2              // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 629   2      
 630   2              break;
 631   2      
 632   2          case RF_KEY_EVENT_ID_4_HOLD: // å¢åŠ  pwm_channel_1 duty
 633   2      
 634   2              expect_adjust_pwm_channel_1_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
             -LD_PRESS_TIME_THRESHOLD_MS);
 635   2              if (expect_adjust_pwm_channel_1_duty > PWM_DUTY_100_PERCENT)
 636   2              {
 637   3                  // é˜²æ­¢æº¢å‡º
 638   3                  expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 639   3              }
 640   2      
 641   2              break;
 642   2      
 643   2          case RF_KEY_EVENT_ID_5_CLICK: // set pwm_channel_0 50%
 644   2          case RF_KEY_EVENT_ID_5_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯å°† pwm_channel_0 è®¾ç½®ä¸º50%
 645   2      
 646   2              // printf("key 5 click\n");
 647   2      
 648   2              expect_adjust_pwm_channel_0_duty = PWM_DUTY_50_PERCENT;
 649   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 650   2              // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 651   2              // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 652   2      
 653   2              break;
 654   2      
 655   2          case RF_KEY_EVENT_ID_6_CLICK: // set pwm_channel_1 50%
 656   2          case RF_KEY_EVENT_ID_6_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯å°† pwm_channel_1 è®¾ç½®ä¸º50%
 657   2      
 658   2              // printf("key 6 click\n");
 659   2      
 660   2              expect_adjust_pwm_channel_1_duty = PWM_DUTY_50_PERCENT;
 661   2              // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 662   2              // cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 663   2              // set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 664   2      
 665   2              break;
 666   2      
 667   2          case RF_KEY_EVENT_ID_7_CLICK: // å‡å° pwm_channel_0 duty
 668   2      
 669   2              // printf("key 7 click\n");
 670   2      
 671   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 672   2              {
 673   3                  // expect_adjust_pwm_channel_0_duty -= (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä
             -»¥æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ä¸º100%ï¼‰
 674   3                  expect_adjust_pwm_channel_0_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 675   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 676   3                  {
 677   4                      expect_adjust_pwm_channel_0_duty = 0;
 678   4                  }
 679   3              }
 680   2              else
 681   2              {
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 13  

 682   3                  // å¦‚æœ  expect_adjust_pwm_channel_0_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 683   3                  expect_adjust_pwm_channel_0_duty = 0;
 684   3              }
 685   2      
 686   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 687   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 688   2      
 689   2              break;
 690   2      
 691   2          case RF_KEY_EVENT_ID_7_HOLD: // å‡å° pwm_channel_0 duty
 692   2      
 693   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 694   2              {
 695   3                  expect_adjust_pwm_channel_0_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 696   3      
 697   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 698   3                  {
 699   4                      expect_adjust_pwm_channel_0_duty = 0;
 700   4                  }
 701   3              }
 702   2              else
 703   2              {
 704   3                  expect_adjust_pwm_channel_0_duty = 0;
 705   3              }
 706   2      
 707   2              break;
 708   2      
 709   2          case RF_KEY_EVENT_ID_8_CLICK: // å‡å° pwm_channel_1 duty
 710   2      
 711   2              // printf("key 8 click\n");
 712   2      
 713   2              if (expect_adjust_pwm_channel_1_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 714   2              {
 715   3                  expect_adjust_pwm_channel_1_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 716   3                  if (expect_adjust_pwm_channel_1_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 717   3                  {
 718   4                      expect_adjust_pwm_channel_1_duty = 0;
 719   4                  }
 720   3              }
 721   2              else
 722   2              {
 723   3                  // å¦‚æœ  expect_adjust_pwm_channel_1_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 724   3                  expect_adjust_pwm_channel_1_duty = 0;
 725   3              }
 726   2      
 727   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 728   2              // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 729   2      
 730   2              break;
 731   2      
 732   2          case RF_KEY_EVENT_ID_8_HOLD: // å‡å° pwm_channel_1 duty
 733   2      
 734   2              if (expect_adjust_pwm_channel_1_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 735   2              {
 736   3                  expect_adjust_pwm_channel_1_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 14  

             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 737   3      
 738   3                  if (expect_adjust_pwm_channel_1_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 739   3                  {
 740   4                      expect_adjust_pwm_channel_1_duty = 0;
 741   4                  }
 742   3              }
 743   2              else
 744   2              {
 745   3                  expect_adjust_pwm_channel_1_duty = 0;
 746   3              }
 747   2      
 748   2              break;
 749   2      
 750   2          // ===========================================================================
 751   2          // åªæ§åˆ¶ä¸€è·¯PWMçš„é¥æ§å™¨ï¼Œåœ¨è½¯ä»¶ä¸Šæ˜¯ä¸¤è·¯ä¸€èµ·æ§åˆ¶
 752   2          case RF_KEY_EVENT_ID_9_CLICK: // åŠ å¤§ pwm_channel_0 å ç©ºæ¯”ï¼› åŠ å¤§ pwm_channel_1 å ç©ºæ¯”
 753   2      
 754   2              // printf("key 9 click\n");
 755   2      
 756   2              expect_adjust_pwm_channel_0_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 757   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 758   2              {
 759   3                  // é˜²æ­¢æº¢å‡º
 760   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 761   3              }
 762   2      
 763   2              expect_adjust_pwm_channel_1_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 764   2              if (expect_adjust_pwm_channel_1_duty > PWM_DUTY_100_PERCENT)
 765   2              {
 766   3                  // é˜²æ­¢æº¢å‡º
 767   3                  expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 768   3              }
 769   2      
 770   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 771   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 772   2      
 773   2              break;
 774   2      
 775   2          case RF_KEY_EVENT_ID_9_HOLD: // åŠ å¤§ pwm_channel_0 å ç©ºæ¯”ï¼› åŠ å¤§ pwm_channel_1 å ç©ºæ¯”
 776   2      
 777   2              // printf("key id 9 hold\n");
 778   2      
 779   2              /*
 780   2                  ç¤ºä¾‹
 781   2                  é•¿æŒ‰è¦å®ç°æ— æè°ƒèŠ‚ï¼Œæ¯æ¬¡æ£€æµ‹åˆ°HOLDçš„æ—¶é—´é—´éš”ä¸º150msï¼Œç¯å…‰äº®åº¦èŒƒå›´0
             -~6000ï¼Œè°ƒèŠ‚æ—¶é—´3s
 782   2                  æ¯æ¬¡æ£€æµ‹åˆ°HOLDçš„æ—¶é—´é—´éš”ä¸º 50ms ï¼Œç¯å…‰äº®åº¦èŒƒå›´ 0~6000ï¼Œè°ƒèŠ‚æ—¶é—´3sï¼Œé‚£
             -ä¹ˆæ¯æ¬¡HOLDè°ƒèŠ‚ 1.6%
 783   2              */
 784   2      
 785   2              // expect_adjust_pwm_channel_0_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡ HOLD è°ƒèŠ‚5%
 786   2              expect_adjust_pwm_channel_0_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
             -LD_PRESS_TIME_THRESHOLD_MS);
 787   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 788   2              {
 789   3                  // é˜²æ­¢æº¢å‡º
 790   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 791   3              }
 792   2      
 793   2              expect_adjust_pwm_channel_1_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 15  

             -LD_PRESS_TIME_THRESHOLD_MS);
 794   2              if (expect_adjust_pwm_channel_1_duty > PWM_DUTY_100_PERCENT)
 795   2              {
 796   3                  // é˜²æ­¢æº¢å‡º
 797   3                  expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 798   3              }
 799   2      
 800   2              break;
 801   2      
 802   2          case RF_KEY_EVENT_ID_10_CLICK: // è®¾ç½® pwm_channel_0 å ç©ºæ¯”ä¸º50%ï¼› è®¾ç½® pwm_channel_1 å ç©ºæ
             -¯”ä¸º50%
 803   2          case RF_KEY_EVENT_ID_10_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ï¼Œä¹Ÿæ˜¯ è®¾ç½® pwm_channel_0 å ç©ºæ¯”ä¸º50%ï¼›è®¾ç
             -½® pwm_channel_1 å ç©ºæ¯”ä¸º50%
 804   2      
 805   2              expect_adjust_pwm_channel_0_duty = PWM_DUTY_50_PERCENT;
 806   2              expect_adjust_pwm_channel_1_duty = PWM_DUTY_50_PERCENT;
 807   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 808   2              // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 809   2              // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 810   2      
 811   2              break;
 812   2      
 813   2          case RF_KEY_EVENT_ID_11_CLICK: // å‡å° pwm_channel_0 å ç©ºæ¯”ï¼›å‡å° pwm_channel_1 å ç©ºæ¯”
 814   2      
 815   2              // printf("key 11 click\n");
 816   2      
 817   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 818   2              {
 819   3                  // expect_adjust_pwm_channel_0_duty -= (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä
             -»¥æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ä¸º100%ï¼‰
 820   3                  expect_adjust_pwm_channel_0_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 821   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 822   3                  {
 823   4                      expect_adjust_pwm_channel_0_duty = 0;
 824   4                  }
 825   3              }
 826   2              else
 827   2              {
 828   3                  // å¦‚æœ  expect_adjust_pwm_channel_0_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 829   3                  expect_adjust_pwm_channel_0_duty = 0;
 830   3              }
 831   2      
 832   2              if (expect_adjust_pwm_channel_1_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 833   2              {
 834   3                  // expect_adjust_pwm_channel_1_duty -= (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä
             -»¥æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ä¸º100%ï¼‰
 835   3                  expect_adjust_pwm_channel_1_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 836   3                  if (expect_adjust_pwm_channel_1_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 837   3                  {
 838   4                      expect_adjust_pwm_channel_1_duty = 0;
 839   4                  }
 840   3              }
 841   2              else
 842   2              {
 843   3                  // å¦‚æœ  expect_adjust_pwm_channel_1_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 844   3                  expect_adjust_pwm_channel_1_duty = 0;
 845   3              }
 846   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 16  

 847   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 848   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 849   2      
 850   2              break;
 851   2      
 852   2          case RF_KEY_EVENT_ID_11_HOLD: // å‡å° pwm_channel_0 å ç©ºæ¯”ï¼›å‡å° pwm_channel_0 å ç©ºæ¯”
 853   2      
 854   2              // printf("key id 11 hold\n");
 855   2      
 856   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 857   2              {
 858   3                  expect_adjust_pwm_channel_0_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 859   3      
 860   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 861   3                  {
 862   4                      expect_adjust_pwm_channel_0_duty = 0;
 863   4                  }
 864   3              }
 865   2              else
 866   2              {
 867   3                  expect_adjust_pwm_channel_0_duty = 0;
 868   3              }
 869   2      
 870   2              if (expect_adjust_pwm_channel_1_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 871   2              {
 872   3                  expect_adjust_pwm_channel_1_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 873   3      
 874   3                  if (expect_adjust_pwm_channel_1_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 875   3                  {
 876   4                      expect_adjust_pwm_channel_1_duty = 0;
 877   4                  }
 878   3              }
 879   2              else
 880   2              {
 881   3                  expect_adjust_pwm_channel_1_duty = 0;
 882   3              }
 883   2      
 884   2              break;
 885   2      
 886   2          case RF_KEY_EVENT_ID_12_CLICK: // æ§åˆ¶ pwm_channel_0 å¼€å…³çš„æŒ‰é”®
 887   2          case RF_KEY_EVENT_ID_12_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ï¼Œä¹Ÿæ˜¯ æ§åˆ¶ pwm_channel_0 å¼€å…³
 888   2      
 889   2              // printf("key 12 click\n");
 890   2              if (get_pwm_channel_0_status() || get_pwm_channel_1_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 891   2              {
 892   3                  expect_adjust_pwm_channel_0_duty = 0;
 893   3                  expect_adjust_pwm_channel_1_duty = 0;
 894   3                  // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(0);
 895   3                  // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°
             -å€¼
 896   3                  // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 897   3                  // pwm_channel_0_disable();
 898   3                  // printf("pwm channel 0 is disable\n");
 899   3              }
 900   2              else // å¦‚æœPWMæœªä½¿èƒ½
 901   2              {
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 17  

 902   3                  expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY;
 903   3                  expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY;
 904   3                  // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 905   3                  // cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°
             -å€¼
 906   3                  // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 907   3                  // pwm_channel_0_enable();
 908   3                  // printf("pwm channel 0 is enable\n");
 909   3              }
 910   2      
 911   2              break;
 912   2      
 913   2      #if USE_MY_TEST_433_REMOTE // æµ‹è¯•æ—¶ä½¿ç”¨çš„é¥æ§å™¨æŒ‰é”®å’ŒåŠŸèƒ½ï¼Œå®é™…ä¸ä½¿ç”¨
              
                  case RF_KEY_EVENT_ID_TEST_1_CLICK:
              
                      // printf("test 1 click\n");
                      if (limited_max_pwm_duty <= (MAX_PWM_DUTY - 500))
                      {
                          limited_max_pwm_duty += 500;
                      }
              
                      break;
              
                  case RF_KEY_EVENT_ID_TEST_2_CLICK:
              
                      // printf("test 2 click\n");
              
                      if (limited_max_pwm_duty >= (0 + 500))
                      {
                          limited_max_pwm_duty -= 500;
                      }
              
                      break;
              
                  case RF_KEY_EVENT_ID_TEST_3_CLICK:
              
                      // printf("test 3 click\n");
              
                      if (limited_pwm_duty_due_to_temp <= (MAX_PWM_DUTY - 500))
                      {
                          limited_pwm_duty_due_to_temp += 500;
                      }
              
                      break;
              
                  case RF_KEY_EVENT_ID_TEST_4_CLICK:
              
                      // printf("test 4 click\n");
              
                      if (limited_pwm_duty_due_to_temp >= (0 + 500))
                      {
                          limited_pwm_duty_due_to_temp -= 500;
                      }
              
                      break;
              
              #endif // #if USE_MY_TEST_433_REMOTE
 959   2      
 960   2          default:
 961   2              break;
 962   2          }
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 18  

 963   1      }
 964          
 965          void rf_recv_init(void)
 966          {
 967   1      // MY_DEBUG:
 968   1      #if USE_MY_TEST_PIN // æµ‹è¯•æ—¶ä½¿ç”¨ï¼Œåœ¨å¼€å‘æ¿ä¸Šä½¿ç”¨ P01 è„šï¼Œç”¨äºæ£€æµ‹rfä¿¡å·
              
                  P0_PU |= GPIO_P01_PULL_UP(0x01);      // ä¸Šæ‹‰
                  P0_MD0 &= ~(GPIO_P01_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
              
              #else // å®é™…ç”¨åˆ°çš„ã€éæµ‹è¯•æ—¶ä½¿ç”¨çš„rfä¿¡å·æ£€æµ‹å¼•è„šï¼š
 974   1      
 975   1          P0_PU |= GPIO_P03_PULL_UP(0x01);      // ä¸Šæ‹‰
 976   1          P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 977   1      
 978   1      #endif // #if USE_MY_TEST_PIN
 979   1      
 980   1          // æ£€æµ‹æœ‰æ— 433é¥æ§å™¨åŠŸèƒ½çš„å¼•è„šï¼š
 981   1          P1_PU |= GPIO_P11_PULL_UP(0x01);      // ä¸Šæ‹‰
 982   1          P1_MD0 &= ~(GPIO_P11_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 983   1      
 984   1          if (0 == RF_ENABLE_PIN) // æ£€æµ‹è„šæ¥äº†0Rç”µé˜»åˆ°GNDï¼Œè¯´æ˜æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 985   1          {
 986   2              flag_is_rf_enable = 1;
 987   2          }
 988   1          else // æ£€æµ‹è„šæœªæ¥0Rç”µé˜»ï¼Œè¯´æ˜æ²¡æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 989   1          {
 990   2              flag_is_rf_enable = 0;
 991   2          }
 992   1      
 993   1          // MY_DEBUG:
 994   1          // flag_is_rf_enable = 1; // æµ‹è¯•æ—¶ä½¿ç”¨ï¼ˆä½¿èƒ½433é¥æ§çš„åŠŸèƒ½ï¼‰
 995   1          // flag_is_rf_enable = 0; // æµ‹è¯•æ—¶ä½¿ç”¨
 996   1      
 997   1          if (flag_is_rf_enable)
 998   1          {
 999   2              flash_read(FLASH_START_ADDR, (u8 *)&rf_remote_info, sizeof(rf_remote_info));
1000   2      
1001   2      #if USE_MY_DEBUG
                      // if (0xC5 == rf_remote_info.is_addr_valid)
                      // {
                      //     printf("rf addr valid\n");
                      // }
                      // else
                      // {
                      //     printf("rf addr unvalid\n");
                      // }
              
                      // printf("rf addr: 0x %lx\n", rf_remote_info.rf_addr);
              #endif
1013   2      
1014   2              flag_is_in_rf_learning = 1; // ä¸Šç”µåï¼Œä½¿èƒ½å¯¹ç åŠŸèƒ½
1015   2          }
1016   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1270    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     95       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.7.0   RF_RECV                                                           01/26/2026 10:01:40 PAGE 19  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
