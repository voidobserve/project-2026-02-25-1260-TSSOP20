C51 COMPILER V9.60.7.0   TIMER3                                                            01/26/2026 10:01:40 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TIMER3
OBJECT MODULE PLACED IN .\Release\Objects\timer3.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\timer3.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCD
                    -IR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\timer3.lst) OBJECT(.\Rele
                    -ase\Objects\timer3.obj)

line level    source

   1          #include "my_config.h"
   2          #include "timer3.h"
   3          
   4          /*
   5              将 timer3 配置为每 935us 产生一次中断的定时器
   6              935us == 0.000935s，转换成频率：
   7              1 / 0.00935 == 1069.518716577540106951871657754 Hz
   8          */
   9          
  10          // 实际测试在935us，如果有其他定时器中断，时间会有误差，在910~960us
  11          #define TIMER3_PERIOD_VAL (SYSCLK / 128 / 1069 - 1) // 周期值=系统时钟/分频/频率 - 1
  12          
  13          void timer3_config(void)
  14          {
  15   1          __EnableIRQ(TMR3_IRQn); // 使能timer3中断
  16   1          IE_EA = 1;              // 使能总中断
  17   1      
  18   1          // 设置timer3的计数功能，配置一个频率为 kHz的中断
  19   1          TMR_ALLCON = TMR3_CNT_CLR(0x1);                               // 清除计数值
  20   1          TMR3_PRH = TMR_PERIOD_VAL_H((TIMER3_PERIOD_VAL >> 8) & 0xFF); // 周期值
  21   1          TMR3_PRL = TMR_PERIOD_VAL_L((TIMER3_PERIOD_VAL >> 0) & 0xFF);
  22   1          TMR3_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // 计数等于周期时
             -许发生中断
  23   1          TMR3_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x1); // 选择系统时钟，1
             -28分频，计数模式
  24   1      }
  25          
  26          void TIMR3_IRQHandler(void) interrupt TMR3_IRQn
  27          {
  28   1          // 进入中断设置IP，不可删除
  29   1          __IRQnIPnPush(TMR3_IRQn);
  30   1      
  31   1          // ---------------- 用户函数处理 -------------------
  32   1          if (0 == (TMR3_CONH & TMR_PRD_PND(0x1)))
  33   1          {
  34   2              // 不是该中断触发（运算之后是非0值，才是该中断触发），直接退出
  35   2              // 退出中断设置IP，不可删除
  36   2              __IRQnIPnPop(TMR3_IRQn);
  37   2              return;
  38   2          }
  39   1      
  40   1          TMR3_CONH |= TMR_PRD_PND(0x1); // 清除中断标志 
  41   1      
  42   1          // 这段代码必须要放在切换通道前面，否则时序和逻辑会有问题
  43   1          {
  44   2              static volatile u8 cnt;
  45   2              static volatile u8 flag_is_time_to_sync_adc_status = 1; // 标志位，是否要同步adc的通道
             -，更新adc状态
  46   2              cnt++;
  47   2              if (cnt >= 8 && flag_is_time_to_sync_adc_status)
  48   2              {
  49   3                  flag_is_time_to_sync_adc_status = 0; 
  50   3                  cur_adc_status = ADC_STATUS_NONE; // 给下面的代码检测到，切换通道
C51 COMPILER V9.60.7.0   TIMER3                                                            01/26/2026 10:01:40 PAGE 2   

  51   3              }
  52   2      
  53   2              if (cnt >= 10)
  54   2              {
  55   3                  cnt = 0;
  56   3                  flag_is_time_to_check_engine = 1;    // 到了检测发动机的时间，让主函数扫描到
             -，调用
  57   3                  flag_is_time_to_sync_adc_status = 1; // 等到下一个周期，同步adc0的通道
  58   3              }
  59   2          }
  60   1      
  61   1      #if 0
                  //
                  if (0 == (ADC_CFG0 & 0x01))
                  {
                      ADC_CFG0 |= 0x01 << 0; // 开启adc0转换
                  }
              
                  if (0 == ((ADC_CFG0 >> 1) & 0x01))
                  {
                      ADC_CFG0 |= 0x01 << 1; // 开启 adc1 转换
                  }
              
                  {
                      static u8 cnt;
                      cnt++;
                      if (cnt >= 10)
                      {
                          cnt = 0;
                          flag_is_time_to_check_engine = 1;
              
                          // 下面这段代码的中断频率不能比adc中断还要快
                          // 每次执行到这里，不用等adc2稳定，因为中断时间间隔比adc2稳定的时
             -还要长
                          if (ADC2_STATUS_NONE == cur_adc2_status ||
                              (ADC2_STATUS_SEL_FAN_DETECT == cur_adc2_status))
                          {
                              // adc2切换至检测热敏电阻的通道，并等待adc2稳定
                              adc2_channel_sel(ADC_SEL_PIN_GET_TEMP);
                              cur_adc2_status = ADC2_STATUS_SEL_GET_TEMP_WAITING;
                          }
                          else if (ADC2_STATUS_SEL_GET_TEMP_WAITING == cur_adc2_status)
                          {
                              ADC_CFG0 |= 0x01 << 2;                      // 开启 adc2 转换
                              cur_adc2_status = ADC2_STATUS_SEL_GET_TEMP; // 表示当前已经切换到了 检测热敏
             -电阻的通道
                          }
                          else if (ADC2_STATUS_SEL_GET_TEMP == cur_adc2_status)
                          {
                              // adc2切换至检测风扇的通道，并等待adc2稳定
                              adc2_channel_sel(ADC_SEL_PIN_FAN_DETECT);
                              cur_adc2_status = ADC2_STATUS_SEL_FAN_DETECT_WAITING;
                          }
                          else if (ADC2_STATUS_SEL_FAN_DETECT_WAITING == cur_adc2_status)
                          {
                              ADC_CFG0 |= 0x01 << 2;                        // 开启 adc2 转换
                              cur_adc2_status = ADC2_STATUS_SEL_FAN_DETECT; // 检测风扇的通道
                          }
                      }
                  }
              #endif
 109   1      
C51 COMPILER V9.60.7.0   TIMER3                                                            01/26/2026 10:01:40 PAGE 3   

 110   1      #if 1
 111   1          // 每次执行到这里，不用等 adc0 稳定，因为中断时间间隔比 adc0 稳定的时间还
             -要长
 112   1          if (ADC_STATUS_NONE == cur_adc_status ||
 113   1              (ADC_STATUS_SEL_FAN_DETECT == cur_adc_status))
 114   1          {
 115   2              // adc0 切换至检测发动机的通道，并等待 adc0 稳定
 116   2              adc_channel_sel(ADC_SEL_PIN_ENGINE);
 117   2              cur_adc_status = ADC_STATUS_SEL_ENGINE_WAITING;
 118   2          }
 119   1          else if (ADC_STATUS_SEL_ENGINE_WAITING == cur_adc_status)
 120   1          {
 121   2              ADC_CFG0 |= 0x01 << 0;                  // 开启adc0转换
 122   2              cur_adc_status = ADC_STATUS_SEL_ENGINE; // 表示当前已经切换到了 检测发动机的通道
 123   2          }
 124   1          // else if (ADC_STATUS_SEL_ENGINE == cur_adc_status)
 125   1          else if (ADC_STATUS_SEL_ENGINE_DONE == cur_adc_status)
 126   1          {
 127   2              // adc0 切换至检测旋钮的通道，并等待 adc0 稳定
 128   2              adc_channel_sel(ADC_SEL_PIN_KNOB);
 129   2              cur_adc_status = ADC_STATUS_SEL_KNOB_WAITING;
 130   2          }
 131   1          else if (ADC_STATUS_SEL_KNOB_WAITING == cur_adc_status)
 132   1          {
 133   2              ADC_CFG0 |= 0x01 << 0;                // 开启adc0转换
 134   2              cur_adc_status = ADC_STATUS_SEL_KNOB; // 检测旋钮的通道 
 135   2          }
 136   1          else if (ADC_STATUS_SEL_KNOB == cur_adc_status)
 137   1          { 
 138   2              // adc0 切换至检测温度的通道，并等待 adc0 稳定
 139   2              adc_channel_sel(ADC_SEL_PIN_TEMP);
 140   2              cur_adc_status = ADC_STATUS_SEL_GET_TEMP_WAITING;
 141   2          }
 142   1          else if (ADC_STATUS_SEL_GET_TEMP_WAITING == cur_adc_status)
 143   1          {
 144   2              ADC_CFG0 |= 0x01 << 0;                    // 开启adc0转换
 145   2              cur_adc_status = ADC_STATUS_SEL_GET_TEMP; // 检测温度的通道 
 146   2          }
 147   1          else if (ADC_STATUS_SEL_GET_TEMP == cur_adc_status)
 148   1          {
 149   2              // adc0 切换至检测风扇的通道，并等待 adc0 稳定
 150   2              adc_channel_sel(ADC_SEL_PIN_FAN);
 151   2              cur_adc_status = ADC_STATUS_SEL_FAN_DETECT_WAITING; 
 152   2          }
 153   1          else if (ADC_STATUS_SEL_FAN_DETECT_WAITING == cur_adc_status)
 154   1          {
 155   2              ADC_CFG0 |= 0x01 << 0;                      // 开启adc0转换
 156   2              cur_adc_status = ADC_STATUS_SEL_FAN_DETECT; // 检测风扇的通道
 157   2          }
 158   1      #endif
 159   1      
 160   1      #if 0
                  // 每次执行到这里，不用等 adc0 稳定，因为中断时间间隔比 adc0 稳定的时间还
             -要长
                  if (ADC_STATUS_NONE == cur_adc_status ||
                      (ADC_STATUS_SEL_GET_TEMP == cur_adc_status))
                  {
                      P05 = 0;
              
                      // adc0 切换至检测发动机的通道，并等待 adc0 稳定
                      adc_channel_sel(ADC_SEL_PIN_ENGINE);
                      cur_adc_status = ADC_STATUS_SEL_ENGINE_WAITING;
C51 COMPILER V9.60.7.0   TIMER3                                                            01/26/2026 10:01:40 PAGE 4   

                  }
                  else if (ADC_STATUS_SEL_ENGINE_WAITING == cur_adc_status)
                  {
                      ADC_CFG0 |= 0x01 << 0;                  // 开启adc0转换
                      cur_adc_status = ADC_STATUS_SEL_ENGINE; // 表示当前已经切换到了 检测发动机的通道
                      P02 = 1;
                  }
                  else if (ADC_STATUS_SEL_ENGINE_DONE == cur_adc_status)
                  {
                      P02 = 0;
                      // adc0 切换至检测温度的通道，并等待 adc0 稳定
                      adc_channel_sel(ADC_SEL_PIN_TEMP);
                      cur_adc_status = ADC_STATUS_SEL_GET_TEMP_WAITING;
                  }
                  else if (ADC_STATUS_SEL_GET_TEMP_WAITING == cur_adc_status)
                  {
                      ADC_CFG0 |= 0x01 << 0;                    // 开启adc0转换
                      cur_adc_status = ADC_STATUS_SEL_GET_TEMP; // 检测温度的通道
                      P05 = 1;
                  }
              #endif
 191   1      
 192   1          __IRQnIPnPop(TMR3_IRQn);
 193   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    293    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
